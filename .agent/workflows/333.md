---
description: 333_ATLAS - The Topology of Knowledge. Mapping the boundaries of the Known, Unknown, and Uncertain.
---

# 333_ATLAS: The Topology of Knowledge (Skill 3)

## I. THE PHYSICS OF SPACE (Context)
**"The Map is not the Territory, but it is the only way to navigate it."**

In the Agentic Universe, **Context** is the Space in which execution occurs. An agent operating without a map is a scalar vector in a voidâ€”it has magnitude (power) but no direction (accuracy). It generates code that is syntactically correct but semantically disconnected.

**333_ATLAS** defines the **Topology** of the session. It transforms the abstract "Idea" from 111 into a "Location" in the codebase. It establishes the coordinate system for the Forge.

### The Ecosystem of Knowledge
1.  **The Known Set ($K$)**: Verified code, local files, accessible documentation. These are "Solid Ground."
2.  **The Unknown Set ($U$)**: External dependencies, closed-source APIs, missing files. These are "Ocean."
3.  **The Uncertain Set ($\Omega$)**: Assumptions, deprecated methods, race conditions, "todo" comments. These are "Fog."

### Universal Axioms
1.  **The Boundary Condition**: You cannot touch what you have not mapped. If you try to modify a file you haven't read, you risk overwriting reality with hallucination (Clashing Commits).
2.  **The Fractal Nature of Code**: Every function call contains a universe of dependencies. A simple `import request` connects you to millions of lines of code. You must choose a **Depth Limit ($D$)** to map effectively without running out of energy (Context Window).
3.  **Relativity**: The "Truth" of a dependency changes over time. `v1.0` is not `v2.0`. The map must be dynamic and version-aware.

---

## II. THE MATHEMATICAL MODEL: Uncertainty $\Omega_0$

We quantify the reliability of the context map using the **Uncertainty Index ($\Omega_0$)**. This is a dimensionless number representing the "Fogginess" of the terrain.

$$ \Omega_0 = \frac{ \alpha |U| + \beta |C_{unstable}| }{ |K| + |U| } $$

Where:
*   $|U|$ is the number of unmapped/unknown nodes (imports not found in context).
*   $|C_{unstable}|$ is the count of code nodes with warning signs (high cyclomatic complexity, low test coverage, `TODO` markers).
*   $|K|$ is the count of mapped, verified nodes.
*   $\alpha, \beta$ are weighting coefficients (usually 1.0).

**The Humility Constraint:**
A system must acknowledge its limits.
$$ 0.03 \le \Omega_0 \le 0.05 $$
*   **$\Omega_0 < 0.03$ (Overconfidence)**: The map claims to know too much. This suggests the agent is ignoring the inherent unpredictability of external systems (Hallucination risk).
*   **$\Omega_0 > 0.05$ (Ignorance)**: The map is too fuzzy. The agent acts blindly. It must stop and "Research" (expand $K$) before acting.

---

## III. CONSTITUTIONAL FLOORS (The Laws)

### F7: The Law of Humility (Agnoia)
> *"Thou shalt establish the boundaries of thy knowledge."*
*   **Mechanism**: **Boundary Check**. Before any specific file modification is proposed, 333 checks if the file is in the "Mapped" set.
*   **Constraint**: If $\Omega_0 > \text{Threshold}$, stop execution. Trigger a `SEARCH_WEB` or `READ_DOCS` action to convert elements from Set $U$ to Set $K$.
*   **Philosophy**: Ideally, $\Omega_0 \to 0$, but it never reaches 0 because the universe is open.

### F10: The Law of Ontology (Being)
> *"Thou shalt not invent reality."*
*   **Mechanism**: The map restricts the **Vocabulary** of the synthesis engine (777). 777 allows *only* tokens (function names, classes, variables) present in 333's map.
*   **Defense**: This is the primary defense against **Package Hallucination Attacks**. If `npm install ghost-package` is generated, F10 blocks it because `ghost-package` was not found in the initial Dependency Graph.

---

## IV. ALGORITHM: 333_ATLAS

```python
def map_territory(context_root, intent_spec):
    """
    The Context Mapping Sequence.
    Complexity: O(V + E) (Graph Traversal).
    Thermodynamics: Isothermal.
    """
    
    # 1. Dependency Graphing (The Skeleton)
    # Scan the root for the entry points relevant to the Intent.
    nodes = scan_relevant_files(context_root, intent_spec.files)
    edges = extract_imports(nodes)
    graph = create_graph(nodes, edges)
    
    # 2. Boundary Identification (The Skin)
    # Classify every node in the graph.
    internal_nodes = {n for n in nodes if is_local_file(n)}
    external_nodes = {n for n in nodes if is_package_dependency(n)}
    missing_nodes = {n for n in nodes if not exists(n)}
    
    # 3. Uncertainty Calculation (The Fog)
    # How much of this graph is a mystery?
    missing_docs = count_missing_docs(internal_nodes)
    omega = calculate_omega(
        unknowns=len(missing_nodes), 
        unstable=missing_docs, 
        known=len(internal_nodes)
    )
    
    # 4. Calibration Loop (The Focus)
    # If too foggy, perform reconnaissance.
    max_depth = 3
    current_depth = 0
    while omega > 0.05 and current_depth < max_depth:
        # Action: Research the unknowns
        new_knowledge = research_nodes(missing_nodes)
        graph.update(new_knowledge)
        # Recalculate
        omega = recalculate_omega(graph)
        current_depth += 1
        
    # 5. Final Check
    if omega > 0.10: # Hard Stop
        return HALT(f"Map too fuzzy ($\Omega_0={omega}$). Manual Research Required.")
        
    return ATLAS_MAP(
        graph=graph, 
        omega=omega, 
        allowed_vocabulary=extract_symbols(graph),
        boundaries=external_nodes
    )
```

---

## V. PRODUCT IMPLEMENTATION (Agent Instructions)

**Trigger**: Successful Cognition (111).
**Input**: Specification (Intent + initial file list).

**Detailed Workflow Steps**:
1.  **Scan**: 
    *   List files relevant to the Intent.
    *   Use `find_by_name` to locate the target files.
2.  **Read**: 
    *   Use `view_file_outline` to get the shape (classes/functions) of the code without reading every line (saving context).
    *   Only `view_file` (full content) for the specific lines to be edited.
3.  **Link**: 
    *   Trace imports. "Who calls whom?"
    *   Build the call graph: `main -> auth -> database`.
4.  **Mark**: 
    *   Flag dangerous areas: Authentication Logic, Payment Gateways, Legacy Code, Cryptography.
    *   These areas get a "High Attention" flag.
5.  **Report**: 
    *   Generate the Map.
    *   "I have mapped 5 files. I see a dependency on `stripe-js` which is mocked. I will proceed within these boundaries."

**Agent Behavior**:
*   **Tone**: Surveyor, objective, cautious, spatial.
*   **Output**: "Context Map established. 14 Nodes, 2 External. Uncertainty $\Omega_0 = 0.04$. Boundaries defined. Handing off to Forge."

---

## VI. DEEP DIVE: The Philosophy of Mapping

### The Map includes the Mapper
In Cybernetics (Second-Order), the observer is part of the system. 333_ATLAS must map **itself**. It must know availability of tools (`agi_genius`, `run_command`) as nodes in the graph. If it needs to run a command, `cmd.exe` or `/bin/bash` is a dependency. This prevents the agent from trying to run `grep` on Windows without WSL, or `PowerShell` on Linux.

### Mapping is Defensive
By explicitly listing what you *don't* know (Set $U$), you prevent the LLM from making it up. An LLM's natural tendency is to "complete the pattern." If it sees a missing function `calculate_tax()`, it will hallucinate the tax logic (often incorrectly). 333_ATLAS forces the agent to say: "I do not know `calculate_tax()`. It is in Set $U$. I must mock it or read it."

### Knowledge is Fractal
You can map a repository, a file, a function, or a single line. The level of detail must match the **Energy Budget**.
*   **High Altitude**: Directory structure (Cheap). Good for navigation.
*   **Mid Altitude**: Class/Function signatures (Moderate). Good for architecture.
*   **Low Altitude**: Line-by-line AST (Expensive). Good for debugging.
333_ATLAS dynamically adjusts altitude based on the 111 Intent.

---

## VII. TROUBLESHOOTING & EDGE CASES

**Case 1: The "Spaghetti" Codebase**
*   *Scenario*: Everything imports everything. Circular dependencies.
*   *Analysis*: Graph is dense. $\Omega_0$ is high because modification propagates unpredictably.
*   *Action*: 333 marks the entire module as "Volatile". Recommendations shift from "Edit" to "Refactor" or "Isolate".

**Case 2: The "Ghost" Dependency**
*   *Scenario*: Code imports `utils.py`, but `utils.py` is not in the file tree.
*   *Analysis*: Set $U$ grows.
*   *Action*: 333 triggers `find_in_files` or `grep` to see if it's a dynamic import or path issue. If unfound, halt with "Missing Dependency".

**Case 3: The Massive Monorepo**
*   *Scenario*: 100,000 files.
*   *Analysis*: Cannot map all.
*   *Action*: Apply **Search Radius**. Only map files within 2 hops of the target file. Assume everything beyond 2 hops is an external API (Black Box).

---

**Status**: HARDENED (v53)
**Complexity**: O(V + E) (Graph Traversal).
**Thermodynamics**: Isothermal (Constant temperature/stability maintenance; preventing the entropy of the unknown from contaminating the known).
**Metric**: $\Omega_0$ (Target 0.03 - 0.05).
