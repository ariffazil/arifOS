============================= test session starts =============================
platform win32 -- Python 3.14.0, pytest-9.0.2, pluggy-1.6.0
rootdir: C:\Users\User\OneDrive\Documents\GitHub\arifOS
configfile: pyproject.toml
plugins: anyio-4.12.0
collected 4 items

tests\test_pipeline_routing.py FFFF                                      [100%]

================================== FAILURES ===================================
__________________ TestTraceAndTiming.test_trace_accumulates __________________

self = <tests.test_pipeline_routing.TestTraceAndTiming object at 0x000002810A032D50>

    def test_trace_accumulates(self):
        """Stage trace should accumulate correctly."""
        pipeline = Pipeline(compute_metrics=TestPipelineRouting._good_metrics, eureka_store=InMemoryStore())
>       state = pipeline.run("test query")
                ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_pipeline_routing.py:329: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\pipeline.py:2330: in run
    state = stage_999_seal(state)
            ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

state = PipelineState(query='test query', job_id='589da90c', stakes_class=<StakesClass.CLASS_A: 'A'>, high_stakes_indicators=[...7.2212572, '111': 1767832547.2220666, '333': 1767832547.2298238, '888': 1767832547.2298365, '999': 1767832547.2443647})

    def stage_999_seal(state: PipelineState) -> PipelineState:
        """
        999 SEAL - If PASS -> emit. If FAIL -> SABAR or VOID.
    
        Final gate. All verdicts are immutably recorded.
    
        v38.1: Enhanced diagnostic messages for SABAR/VOID.
        v38.2-alpha: L7 Memory store with EUREKA Sieve (fail-open).
        v43: FAIL-CLOSED - blocks SEAL if ledger write failed.
        v45.0: APEX uses @PROMPT tool for exit gate check (final constitutional guardian).
               Special crisis 888_HOLD handling (compassionate safe handoff).
        """
        state.current_stage = "999"
        state.stage_trace.append("999_SEAL")
        state.stage_times["999"] = time.time()
    
        # SABAR-72 v43: Time Governor - Check for active cooling hold
        sabar_timer = Sabar72Timer()
        if sabar_timer.is_blocked(state.job_id):
            ticket = sabar_timer.get_ticket(state.job_id)
            import logging
    
            logging.getLogger(__name__).warning(
                f"SABAR-72 enforced for job {state.job_id}. "
                f"Reason: {ticket.reason.value if ticket else 'unknown'}. "
                f"Cooling period: {ticket.hours_remaining():.1f}h remaining."
            )
            state.verdict = "SABAR"
            state.floor_failures.append(
                f"SABAR_72_ACTIVE: {ticket.reason.value} ({ticket.hours_remaining():.1f}h remaining)"
            )
            state.sabar_reason = (
                f"Constitutional cooling period (72h) enforced. "
                f"Reason: {ticket.reason.value}. Time remaining: {ticket.hours_remaining():.1f} hours. "
                f"Human authority override required to proceed before expiry."
            )
    
        # ==========================================================================
        # v45\u03a9 PATCH 3 (continued): Conditional fail-closed based on stakes
        # ==========================================================================
        # FAIL-CLOSED v43 (amended v45): Block SEAL emission if ledger write failed
        # BUT: Separate "audit degradation" from "truth violation"
        # - High-stakes (CLASS_B): Still fail-closed to VOID
        # - Low-stakes: Allow DEGRADED status with warning
        # ==========================================================================
        if not getattr(state, "ledger_write_success", True):
            ledger_status = getattr(state, "ledger_status", "UNKNOWN")
            import logging
    
            # Check if this is a high-stakes query
            is_high_stakes = state.stakes_class == StakesClass.CLASS_B
    
            if is_high_stakes or ledger_status == "CRITICAL_FAILURE":
                # High-stakes OR critical failure \u2192 hard fail-closed to VOID
                logging.getLogger(__name__).info(
                    f"Audit trail preservation incomplete (status: {ledger_status}). "
                    f"Transitioning to VOID per high-stakes protocol. Query preserved in memory."
                )
                state.verdict = "VOID"
                # Add to floor_failures for transparency
                state.floor_failures.append("LEDGER_WRITE_FAILED (fail-closed enforcement)")
                state.sabar_reason = (
                    "Ledger write failure on high-stakes query - "
                    "cannot emit governed output without audit trail"
                )
            else:
                # Low-stakes with DEGRADED ledger \u2192 allow with warning
                logging.getLogger(__name__).warning(
                    f"Ledger write degraded for LOW-STAKES job {state.job_id}. "
                    f"Verdict {state.verdict} allowed with audit degradation warning. "
                    f"Ledger status: {ledger_status}"
                )
                # Downgrade SEAL to PARTIAL if ledger is degraded
                if state.verdict == "SEAL":
                    state.verdict = "PARTIAL"
                    state.floor_failures.append(
                        f"LEDGER_DEGRADED (emergency fallback active, status: {ledger_status})"
                    )
        # ==========================================================================
        # END PATCH 3: Conditional fail-closed
        # ==========================================================================
    
        # v45.0: APEX uses @PROMPT tool for exit gate check (final constitutional guardian)
        # This follows agent-tool pattern: APEX (agent) uses @PROMPT (tool), APEX decides final verdict
        if state.verdict in ("SEAL", "PARTIAL"):
>           from ..waw.prompt import PromptOrgan
E           ModuleNotFoundError: No module named 'arifos_core.waw'

arifos_core\system\pipeline.py:1938: ModuleNotFoundError
------------------------------ Captured log call ------------------------------
ERROR    arifos_core.system.runtime.bootstrap:bootstrap.py:30 Spec binding validation failed: required spec missing: spec/v42/genius_law.json
________________ TestTraceAndTiming.test_stage_times_recorded _________________

self = <tests.test_pipeline_routing.TestTraceAndTiming object at 0x000002816C6E7B10>

    def test_stage_times_recorded(self):
        """Stage times should be recorded."""
        pipeline = Pipeline(compute_metrics=TestPipelineRouting._good_metrics, eureka_store=InMemoryStore())
>       state = pipeline.run("test query")
                ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_pipeline_routing.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\pipeline.py:2330: in run
    state = stage_999_seal(state)
            ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

state = PipelineState(query='test query', job_id='b4f17034', stakes_class=<StakesClass.CLASS_A: 'A'>, high_stakes_indicators=[...548.4460137, '111': 1767832548.4473386, '333': 1767832548.447796, '888': 1767832548.447811, '999': 1767832548.4580407})

    def stage_999_seal(state: PipelineState) -> PipelineState:
        """
        999 SEAL - If PASS -> emit. If FAIL -> SABAR or VOID.
    
        Final gate. All verdicts are immutably recorded.
    
        v38.1: Enhanced diagnostic messages for SABAR/VOID.
        v38.2-alpha: L7 Memory store with EUREKA Sieve (fail-open).
        v43: FAIL-CLOSED - blocks SEAL if ledger write failed.
        v45.0: APEX uses @PROMPT tool for exit gate check (final constitutional guardian).
               Special crisis 888_HOLD handling (compassionate safe handoff).
        """
        state.current_stage = "999"
        state.stage_trace.append("999_SEAL")
        state.stage_times["999"] = time.time()
    
        # SABAR-72 v43: Time Governor - Check for active cooling hold
        sabar_timer = Sabar72Timer()
        if sabar_timer.is_blocked(state.job_id):
            ticket = sabar_timer.get_ticket(state.job_id)
            import logging
    
            logging.getLogger(__name__).warning(
                f"SABAR-72 enforced for job {state.job_id}. "
                f"Reason: {ticket.reason.value if ticket else 'unknown'}. "
                f"Cooling period: {ticket.hours_remaining():.1f}h remaining."
            )
            state.verdict = "SABAR"
            state.floor_failures.append(
                f"SABAR_72_ACTIVE: {ticket.reason.value} ({ticket.hours_remaining():.1f}h remaining)"
            )
            state.sabar_reason = (
                f"Constitutional cooling period (72h) enforced. "
                f"Reason: {ticket.reason.value}. Time remaining: {ticket.hours_remaining():.1f} hours. "
                f"Human authority override required to proceed before expiry."
            )
    
        # ==========================================================================
        # v45\u03a9 PATCH 3 (continued): Conditional fail-closed based on stakes
        # ==========================================================================
        # FAIL-CLOSED v43 (amended v45): Block SEAL emission if ledger write failed
        # BUT: Separate "audit degradation" from "truth violation"
        # - High-stakes (CLASS_B): Still fail-closed to VOID
        # - Low-stakes: Allow DEGRADED status with warning
        # ==========================================================================
        if not getattr(state, "ledger_write_success", True):
            ledger_status = getattr(state, "ledger_status", "UNKNOWN")
            import logging
    
            # Check if this is a high-stakes query
            is_high_stakes = state.stakes_class == StakesClass.CLASS_B
    
            if is_high_stakes or ledger_status == "CRITICAL_FAILURE":
                # High-stakes OR critical failure \u2192 hard fail-closed to VOID
                logging.getLogger(__name__).info(
                    f"Audit trail preservation incomplete (status: {ledger_status}). "
                    f"Transitioning to VOID per high-stakes protocol. Query preserved in memory."
                )
                state.verdict = "VOID"
                # Add to floor_failures for transparency
                state.floor_failures.append("LEDGER_WRITE_FAILED (fail-closed enforcement)")
                state.sabar_reason = (
                    "Ledger write failure on high-stakes query - "
                    "cannot emit governed output without audit trail"
                )
            else:
                # Low-stakes with DEGRADED ledger \u2192 allow with warning
                logging.getLogger(__name__).warning(
                    f"Ledger write degraded for LOW-STAKES job {state.job_id}. "
                    f"Verdict {state.verdict} allowed with audit degradation warning. "
                    f"Ledger status: {ledger_status}"
                )
                # Downgrade SEAL to PARTIAL if ledger is degraded
                if state.verdict == "SEAL":
                    state.verdict = "PARTIAL"
                    state.floor_failures.append(
                        f"LEDGER_DEGRADED (emergency fallback active, status: {ledger_status})"
                    )
        # ==========================================================================
        # END PATCH 3: Conditional fail-closed
        # ==========================================================================
    
        # v45.0: APEX uses @PROMPT tool for exit gate check (final constitutional guardian)
        # This follows agent-tool pattern: APEX (agent) uses @PROMPT (tool), APEX decides final verdict
        if state.verdict in ("SEAL", "PARTIAL"):
>           from ..waw.prompt import PromptOrgan
E           ModuleNotFoundError: No module named 'arifos_core.waw'

arifos_core\system\pipeline.py:1938: ModuleNotFoundError
------------------------------ Captured log call ------------------------------
ERROR    arifos_core.system.runtime.bootstrap:bootstrap.py:30 Spec binding validation failed: required spec missing: spec/v42/genius_law.json
__________________ TestTraceAndTiming.test_job_id_generated ___________________

self = <tests.test_pipeline_routing.TestTraceAndTiming object at 0x000002810A0A6520>

    def test_job_id_generated(self):
        """Job ID should be generated if not provided."""
        pipeline = Pipeline(compute_metrics=TestPipelineRouting._good_metrics, eureka_store=InMemoryStore())
>       state = pipeline.run("test query")
                ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_pipeline_routing.py:351: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\pipeline.py:2330: in run
    state = stage_999_seal(state)
            ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

state = PipelineState(query='test query', job_id='ca2fd9a4', stakes_class=<StakesClass.CLASS_A: 'A'>, high_stakes_indicators=[...8.5438013, '111': 1767832548.5446012, '333': 1767832548.5449028, '888': 1767832548.5449092, '999': 1767832548.5541816})

    def stage_999_seal(state: PipelineState) -> PipelineState:
        """
        999 SEAL - If PASS -> emit. If FAIL -> SABAR or VOID.
    
        Final gate. All verdicts are immutably recorded.
    
        v38.1: Enhanced diagnostic messages for SABAR/VOID.
        v38.2-alpha: L7 Memory store with EUREKA Sieve (fail-open).
        v43: FAIL-CLOSED - blocks SEAL if ledger write failed.
        v45.0: APEX uses @PROMPT tool for exit gate check (final constitutional guardian).
               Special crisis 888_HOLD handling (compassionate safe handoff).
        """
        state.current_stage = "999"
        state.stage_trace.append("999_SEAL")
        state.stage_times["999"] = time.time()
    
        # SABAR-72 v43: Time Governor - Check for active cooling hold
        sabar_timer = Sabar72Timer()
        if sabar_timer.is_blocked(state.job_id):
            ticket = sabar_timer.get_ticket(state.job_id)
            import logging
    
            logging.getLogger(__name__).warning(
                f"SABAR-72 enforced for job {state.job_id}. "
                f"Reason: {ticket.reason.value if ticket else 'unknown'}. "
                f"Cooling period: {ticket.hours_remaining():.1f}h remaining."
            )
            state.verdict = "SABAR"
            state.floor_failures.append(
                f"SABAR_72_ACTIVE: {ticket.reason.value} ({ticket.hours_remaining():.1f}h remaining)"
            )
            state.sabar_reason = (
                f"Constitutional cooling period (72h) enforced. "
                f"Reason: {ticket.reason.value}. Time remaining: {ticket.hours_remaining():.1f} hours. "
                f"Human authority override required to proceed before expiry."
            )
    
        # ==========================================================================
        # v45\u03a9 PATCH 3 (continued): Conditional fail-closed based on stakes
        # ==========================================================================
        # FAIL-CLOSED v43 (amended v45): Block SEAL emission if ledger write failed
        # BUT: Separate "audit degradation" from "truth violation"
        # - High-stakes (CLASS_B): Still fail-closed to VOID
        # - Low-stakes: Allow DEGRADED status with warning
        # ==========================================================================
        if not getattr(state, "ledger_write_success", True):
            ledger_status = getattr(state, "ledger_status", "UNKNOWN")
            import logging
    
            # Check if this is a high-stakes query
            is_high_stakes = state.stakes_class == StakesClass.CLASS_B
    
            if is_high_stakes or ledger_status == "CRITICAL_FAILURE":
                # High-stakes OR critical failure \u2192 hard fail-closed to VOID
                logging.getLogger(__name__).info(
                    f"Audit trail preservation incomplete (status: {ledger_status}). "
                    f"Transitioning to VOID per high-stakes protocol. Query preserved in memory."
                )
                state.verdict = "VOID"
                # Add to floor_failures for transparency
                state.floor_failures.append("LEDGER_WRITE_FAILED (fail-closed enforcement)")
                state.sabar_reason = (
                    "Ledger write failure on high-stakes query - "
                    "cannot emit governed output without audit trail"
                )
            else:
                # Low-stakes with DEGRADED ledger \u2192 allow with warning
                logging.getLogger(__name__).warning(
                    f"Ledger write degraded for LOW-STAKES job {state.job_id}. "
                    f"Verdict {state.verdict} allowed with audit degradation warning. "
                    f"Ledger status: {ledger_status}"
                )
                # Downgrade SEAL to PARTIAL if ledger is degraded
                if state.verdict == "SEAL":
                    state.verdict = "PARTIAL"
                    state.floor_failures.append(
                        f"LEDGER_DEGRADED (emergency fallback active, status: {ledger_status})"
                    )
        # ==========================================================================
        # END PATCH 3: Conditional fail-closed
        # ==========================================================================
    
        # v45.0: APEX uses @PROMPT tool for exit gate check (final constitutional guardian)
        # This follows agent-tool pattern: APEX (agent) uses @PROMPT (tool), APEX decides final verdict
        if state.verdict in ("SEAL", "PARTIAL"):
>           from ..waw.prompt import PromptOrgan
E           ModuleNotFoundError: No module named 'arifos_core.waw'

arifos_core\system\pipeline.py:1938: ModuleNotFoundError
------------------------------ Captured log call ------------------------------
ERROR    arifos_core.system.runtime.bootstrap:bootstrap.py:30 Spec binding validation failed: required spec missing: spec/v42/genius_law.json
__________________ TestTraceAndTiming.test_job_id_preserved ___________________

self = <tests.test_pipeline_routing.TestTraceAndTiming object at 0x000002816C6E2EA0>

    def test_job_id_preserved(self):
        """Job ID should be preserved if provided."""
        pipeline = Pipeline(compute_metrics=TestPipelineRouting._good_metrics, eureka_store=InMemoryStore())
>       state = pipeline.run("test query", job_id="custom-id-123")
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_pipeline_routing.py:359: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\pipeline.py:2330: in run
    state = stage_999_seal(state)
            ^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

state = PipelineState(query='test query', job_id='custom-id-123', stakes_class=<StakesClass.CLASS_A: 'A'>, high_stakes_indicat...48.6134555, '111': 1767832548.614379, '333': 1767832548.6146615, '888': 1767832548.6146765, '999': 1767832548.6248188})

    def stage_999_seal(state: PipelineState) -> PipelineState:
        """
        999 SEAL - If PASS -> emit. If FAIL -> SABAR or VOID.
    
        Final gate. All verdicts are immutably recorded.
    
        v38.1: Enhanced diagnostic messages for SABAR/VOID.
        v38.2-alpha: L7 Memory store with EUREKA Sieve (fail-open).
        v43: FAIL-CLOSED - blocks SEAL if ledger write failed.
        v45.0: APEX uses @PROMPT tool for exit gate check (final constitutional guardian).
               Special crisis 888_HOLD handling (compassionate safe handoff).
        """
        state.current_stage = "999"
        state.stage_trace.append("999_SEAL")
        state.stage_times["999"] = time.time()
    
        # SABAR-72 v43: Time Governor - Check for active cooling hold
        sabar_timer = Sabar72Timer()
        if sabar_timer.is_blocked(state.job_id):
            ticket = sabar_timer.get_ticket(state.job_id)
            import logging
    
            logging.getLogger(__name__).warning(
                f"SABAR-72 enforced for job {state.job_id}. "
                f"Reason: {ticket.reason.value if ticket else 'unknown'}. "
                f"Cooling period: {ticket.hours_remaining():.1f}h remaining."
            )
            state.verdict = "SABAR"
            state.floor_failures.append(
                f"SABAR_72_ACTIVE: {ticket.reason.value} ({ticket.hours_remaining():.1f}h remaining)"
            )
            state.sabar_reason = (
                f"Constitutional cooling period (72h) enforced. "
                f"Reason: {ticket.reason.value}. Time remaining: {ticket.hours_remaining():.1f} hours. "
                f"Human authority override required to proceed before expiry."
            )
    
        # ==========================================================================
        # v45\u03a9 PATCH 3 (continued): Conditional fail-closed based on stakes
        # ==========================================================================
        # FAIL-CLOSED v43 (amended v45): Block SEAL emission if ledger write failed
        # BUT: Separate "audit degradation" from "truth violation"
        # - High-stakes (CLASS_B): Still fail-closed to VOID
        # - Low-stakes: Allow DEGRADED status with warning
        # ==========================================================================
        if not getattr(state, "ledger_write_success", True):
            ledger_status = getattr(state, "ledger_status", "UNKNOWN")
            import logging
    
            # Check if this is a high-stakes query
            is_high_stakes = state.stakes_class == StakesClass.CLASS_B
    
            if is_high_stakes or ledger_status == "CRITICAL_FAILURE":
                # High-stakes OR critical failure \u2192 hard fail-closed to VOID
                logging.getLogger(__name__).info(
                    f"Audit trail preservation incomplete (status: {ledger_status}). "
                    f"Transitioning to VOID per high-stakes protocol. Query preserved in memory."
                )
                state.verdict = "VOID"
                # Add to floor_failures for transparency
                state.floor_failures.append("LEDGER_WRITE_FAILED (fail-closed enforcement)")
                state.sabar_reason = (
                    "Ledger write failure on high-stakes query - "
                    "cannot emit governed output without audit trail"
                )
            else:
                # Low-stakes with DEGRADED ledger \u2192 allow with warning
                logging.getLogger(__name__).warning(
                    f"Ledger write degraded for LOW-STAKES job {state.job_id}. "
                    f"Verdict {state.verdict} allowed with audit degradation warning. "
                    f"Ledger status: {ledger_status}"
                )
                # Downgrade SEAL to PARTIAL if ledger is degraded
                if state.verdict == "SEAL":
                    state.verdict = "PARTIAL"
                    state.floor_failures.append(
                        f"LEDGER_DEGRADED (emergency fallback active, status: {ledger_status})"
                    )
        # ==========================================================================
        # END PATCH 3: Conditional fail-closed
        # ==========================================================================
    
        # v45.0: APEX uses @PROMPT tool for exit gate check (final constitutional guardian)
        # This follows agent-tool pattern: APEX (agent) uses @PROMPT (tool), APEX decides final verdict
        if state.verdict in ("SEAL", "PARTIAL"):
>           from ..waw.prompt import PromptOrgan
E           ModuleNotFoundError: No module named 'arifos_core.waw'

arifos_core\system\pipeline.py:1938: ModuleNotFoundError
------------------------------ Captured log call ------------------------------
ERROR    arifos_core.system.runtime.bootstrap:bootstrap.py:30 Spec binding validation failed: required spec missing: spec/v42/genius_law.json
============================== warnings summary ===============================
.venv\Lib\site-packages\litellm\litellm_core_utils\logging_utils.py:273: 17 warnings
  C:\Users\User\OneDrive\Documents\GitHub\arifOS\.venv\Lib\site-packages\litellm\litellm_core_utils\logging_utils.py:273: DeprecationWarning: 'asyncio.iscoroutinefunction' is deprecated and slated for removal in Python 3.16; use inspect.iscoroutinefunction() instead
    if asyncio.iscoroutinefunction(func):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/test_pipeline_routing.py::TestTraceAndTiming::test_trace_accumulates
FAILED tests/test_pipeline_routing.py::TestTraceAndTiming::test_stage_times_recorded
FAILED tests/test_pipeline_routing.py::TestTraceAndTiming::test_job_id_generated
FAILED tests/test_pipeline_routing.py::TestTraceAndTiming::test_job_id_preserved
======================= 4 failed, 17 warnings in 8.98s ========================
