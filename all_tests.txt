============================= test session starts =============================
platform win32 -- Python 3.14.0, pytest-8.4.2, pluggy-1.6.0
rootdir: C:\Users\User\OneDrive\Documents\GitHub\arifOS
configfile: pyproject.toml
testpaths: tests
plugins: anyio-4.11.0, asyncio-1.3.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 2112 items

tests\evidence\test_atomic_ingestion.py ....                             [  0%]
tests\evidence\test_conflict_routing.py ....                             [  0%]
tests\evidence\test_evidence_pack.py ...                                 [  0%]
tests\governance\test_merkle_ledger.py ....                              [  0%]
tests\governance\test_proof_of_governance.py ....                        [  0%]
tests\governance\test_signatures.py ...                                  [  1%]
tests\integration\test_failover_pipeline.py .....F.                      [  1%]
tests\integration\test_memory_floor_integration.py ..................... [  2%]
...............                                                          [  3%]
tests\integration\test_memory_policy_spec_alignment.py .....F......s..s. [  3%]
...............                                                          [  4%]
tests\integration\test_pipeline_with_memory.py ...........               [  5%]
tests\integration\test_sealion_api_key_detection.py ...FF                [  5%]
tests\judiciary\test_firewall.py ...                                     [  5%]
tests\judiciary\test_witness_council.py ....                             [  5%]
tests\temporal\test_freshness.py ...                                     [  5%]
tests\temporal\test_phoenix_hold.py ......                               [  6%]
tests\test_aclip_bridge.py ...............                               [  6%]
tests\test_amanah_detector.py .......................................... [  8%]
...............................                                          [ 10%]
tests\test_anti_hantu_f9.py ....                                         [ 10%]
tests\test_antihantu_unit.py ...                                         [ 10%]
tests\test_apex_and_ledger_edges.py sss                                  [ 10%]
tests\test_apex_genius_verdicts.py ..................................... [ 12%]
                                                                         [ 12%]
tests\test_apex_measurements_eval.py ................................... [ 14%]
..........                                                               [ 14%]
tests\test_apex_prime_floors.py ............................             [ 15%]
tests\test_apex_prime_floors_mocked.py ............s....                 [ 16%]
tests\test_apex_review.py ...                                            [ 16%]
tests\test_api_contract.py ............................................. [ 19%]
......                                                                   [ 19%]
tests\test_caged_llm_harness.py .............F.F...........              [ 20%]
tests\test_canon_drift_guard.py ......EEEEEEEEEE............EEE          [ 22%]
tests\test_codex_ledger.py ..                                            [ 22%]
tests\test_cooling_ledger.py .                                           [ 22%]
tests\test_cooling_ledger_integrity.py ...............                   [ 22%]
tests\test_cooling_ledger_integrity_mocked.py ...........                [ 23%]
tests\test_cooling_ledger_kms_integration.py ...                         [ 23%]
tests\test_cooling_ledger_schema_compliance.py ...                       [ 23%]
tests\test_dream_forge.py ....................................           [ 25%]
tests\test_engines_arif_adam.py ................................         [ 26%]
tests\test_epoch_comparison.py ..........................F.......        [ 28%]
tests\test_eye_sentinel.py ...............................               [ 30%]
tests\test_fag.py ............                                           [ 30%]
tests\test_fag_hardening.py ....................                         [ 31%]
tests\test_fag_statistics_audit.py ............                          [ 32%]
tests\test_fag_write.py ...........                                      [ 32%]
tests\test_failover_orchestrator.py F.......F.............F...           [ 33%]
tests\test_federation_router.py ..................................       [ 35%]
tests\test_genius_metrics.py ........................................... [ 37%]
.........................                                                [ 38%]
tests\test_governance_regression.py .....FFFFFF............F             [ 39%]
tests\test_governed_llm.py .F.                                           [ 39%]
tests\test_governed_session_wrapper.py ...                               [ 40%]
tests\test_grey_zone.py ........................                         [ 41%]
tests\test_ignition_profiles.py ...                                      [ 41%]
tests\test_integration_common_utils.py ..........                        [ 41%]
tests\test_kms_signer.py .                                               [ 41%]
tests\test_lane_routing.py .....                                         [ 42%]
tests\test_law_f3_f6_threshold_enforcement.py ..........                 [ 42%]
tests\test_law_truth_threshold_enforcement.py ..FFF...F                  [ 43%]
tests\test_ledger_cryptography.py .....................                  [ 44%]
tests\test_ledger_sanity.py ..........                                   [ 44%]
tests\test_llm_adapters.py .....................                         [ 45%]
tests\test_llm_audit_trail.py .F..                                       [ 45%]
tests\test_mcp_000_reset.py ..............                               [ 46%]
tests\test_mcp_111_sense.py ...............................              [ 47%]
tests\test_mcp_222_reflect.py ..........................                 [ 49%]
tests\test_mcp_444_evidence.py ..............................            [ 50%]
tests\test_mcp_555_empathize.py ........................                 [ 51%]
tests\test_mcp_666_align.py .........                                    [ 52%]
tests\test_mcp_777_forge.py ..............                               [ 52%]
tests\test_mcp_888_judge.py ....................                         [ 53%]
tests\test_mcp_889_proof.py ...................                          [ 54%]
tests\test_mcp_999_seal.py ....................                          [ 55%]
tests\test_mcp_fag_integration.py ...........                            [ 56%]
tests\test_mcp_integration_phase3.py ...............                     [ 56%]
tests\test_mcp_v0_strict.py ...............                              [ 57%]
tests\test_memory_enforcement_v37.py ................                    [ 58%]
tests\test_memory_phase1_invariants.py ........                          [ 58%]
tests\test_memory_phase1_routing.py ..........                           [ 59%]
tests\test_memory_phase2_integration.py ..                               [ 59%]
tests\test_memory_stack_v37.py .........................                 [ 60%]
tests\test_phatic_exemptions.py ....                                     [ 60%]
tests\test_phoenix72.py .                                                [ 60%]
tests\test_phoenix_72_entropy_rot.py .....................               [ 61%]
tests\test_phoenix_72_guardrail.py ..F.                                  [ 61%]
tests\test_pipeline_routing.py ...F......F.........                      [ 62%]
tests\test_pipeline_stages_444_555_666.py ......                         [ 62%]
tests\test_pipeline_waw_integration.py ...................               [ 63%]
tests\test_runtime_manifest.py FFFFFFEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE [ 65%]
EEEEEEEEEEEEEEE...F.                                                     [ 66%]
tests\test_sabar_partial_separation.py ........                          [ 67%]
tests\test_ses_enforcement.py ......                                     [ 67%]
tests\test_session_dependency_guard.py ....                              [ 67%]
tests\test_session_physics.py ....                                       [ 67%]
tests\test_sovereignty_all_providers.py ................................ [ 69%]
....FFFF...                                                              [ 69%]
tests\test_spec_loader_unified.py .......FFFFF...F                       [ 70%]
tests\test_spec_v44_authority.py ......s..s....s..                       [ 71%]
tests\test_spec_v44_manifest_enforcement_subprocess.py F.FFF...          [ 71%]
tests\test_spec_v44_schema_enforcement_subprocess.py ..F.F..             [ 72%]
tests\test_spec_v44_subprocess_proof.py FFFFFF.                          [ 72%]
tests\test_tearframe_integration.py ...                                  [ 72%]
tests\test_time_immutability.py .......                                  [ 72%]
tests\test_trinity.py ..........s                                        [ 73%]
tests\test_v39_ci_guardrails.py FFFF.FFF.....                            [ 74%]
tests\test_v45_patch_b1_fixes.py .F............                          [ 74%]
tests\test_vector_adapter.py ..                                          [ 74%]
tests\test_void_stress.py .............................................. [ 76%]
...........................................................              [ 79%]
tests\test_waw_apex_escalation.py ........                               [ 80%]
tests\test_waw_geox_signals.py ......................................... [ 82%]
                                                                         [ 82%]
tests\test_waw_organs.py ............................................... [ 84%]
.......                                                                  [ 84%]
tests\test_waw_prompt_signals.py .............................           [ 86%]
tests\test_waw_rif_signals.py .........................................  [ 87%]
tests\test_waw_wealth_signals.py ................................        [ 89%]
tests\test_waw_well_signals.py ......................................... [ 91%]
.........                                                                [ 91%]
tests\unit\test_api_app.py ...................................           [ 93%]
tests\unit\test_l7_memory.py ........................................... [ 95%]
...........................                                              [ 96%]
tests\unit\test_mcp_server.py ....................................       [ 98%]
tests\unit\test_memory_band_router_unit.py ............................. [ 99%]
..                                                                       [100%]

=================================== ERRORS ====================================
_ ERROR at setup of TestConstitutionalFloorsJsonMatchesMetrics.test_truth_threshold_matches _

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
_ ERROR at setup of TestConstitutionalFloorsJsonMatchesMetrics.test_delta_s_threshold_matches _

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
_ ERROR at setup of TestConstitutionalFloorsJsonMatchesMetrics.test_peace_squared_threshold_matches _

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
_ ERROR at setup of TestConstitutionalFloorsJsonMatchesMetrics.test_kappa_r_threshold_matches _

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
_ ERROR at setup of TestConstitutionalFloorsJsonMatchesMetrics.test_omega_0_band_matches _

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
_ ERROR at setup of TestConstitutionalFloorsJsonMatchesMetrics.test_tri_witness_threshold_matches _

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
_ ERROR at setup of TestConstitutionalFloorsJsonMatchesMetrics.test_psi_threshold_matches _

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
____ ERROR at setup of TestFloorCategoriesMatchCanon.test_hard_floors_list ____

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
____ ERROR at setup of TestFloorCategoriesMatchCanon.test_soft_floors_list ____

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
____ ERROR at setup of TestFloorCategoriesMatchCanon.test_meta_floors_list ____

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
____ ERROR at setup of TestAntiHantuFloorType.test_anti_hantu_is_meta_type ____

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
_ ERROR at setup of TestAntiHantuFloorType.test_anti_hantu_failure_action_is_void _

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
__ ERROR at setup of TestAntiHantuFloorType.test_anti_hantu_enforced_by_eye ___

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')

    @pytest.fixture
    def constitutional_floors_json(repo_root) -> dict:
        """Load constitutional_floors.json."""
        path = repo_root / "integrations" / "sealion" / "constitutional_floors.json"
>       assert path.exists(), f"constitutional_floors.json not found at {path}"
E       AssertionError: constitutional_floors.json not found at C:\Users\User\OneDrive\Documents\GitHub\arifOS\integrations\sealion\constitutional_floors.json
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/integrations/sealion/constitutional_floors.json').exists

tests\test_canon_drift_guard.py:63: AssertionError
__ ERROR at setup of TestFloorThresholdDriftV35.test_truth_threshold_matches __

self = <tests.test_runtime_manifest.TestFloorThresholdDriftV35 object at 0x000002703872D590>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestFloorThresholdDriftV35.test_delta_s_threshold_matches _

self = <tests.test_runtime_manifest.TestFloorThresholdDriftV35 object at 0x000002703872D450>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestFloorThresholdDriftV35.test_peace_squared_threshold_matches _

self = <tests.test_runtime_manifest.TestFloorThresholdDriftV35 object at 0x000002703873CC30>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestFloorThresholdDriftV35.test_kappa_r_threshold_matches _

self = <tests.test_runtime_manifest.TestFloorThresholdDriftV35 object at 0x000002703873CD60>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestFloorThresholdDriftV35.test_omega_0_min_matches ____

self = <tests.test_runtime_manifest.TestFloorThresholdDriftV35 object at 0x000002703F863E30>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestFloorThresholdDriftV35.test_omega_0_max_matches ____

self = <tests.test_runtime_manifest.TestFloorThresholdDriftV35 object at 0x000002703869A580>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestFloorThresholdDriftV35.test_tri_witness_threshold_matches _

self = <tests.test_runtime_manifest.TestFloorThresholdDriftV35 object at 0x000002703869A690>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
___ ERROR at setup of TestFloorThresholdDriftV35.test_psi_threshold_matches ___

self = <tests.test_runtime_manifest.TestFloorThresholdDriftV35 object at 0x000002703F928450>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestFloorThresholdDriftV35.test_metrics_threshold_constants_match _

self = <tests.test_runtime_manifest.TestFloorThresholdDriftV35 object at 0x000002703F928650>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
________ ERROR at setup of TestPipelineStagesV35.test_stage_000_exists ________

self = <tests.test_runtime_manifest.TestPipelineStagesV35 object at 0x000002703872D810>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
________ ERROR at setup of TestPipelineStagesV35.test_stage_999_exists ________

self = <tests.test_runtime_manifest.TestPipelineStagesV35 object at 0x000002703872D6D0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_____ ERROR at setup of TestPipelineStagesV35.test_all_ten_stages_defined _____

self = <tests.test_runtime_manifest.TestPipelineStagesV35 object at 0x000002703873CE90>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_______ ERROR at setup of TestPipelineStagesV35.test_stage_000_is_void ________

self = <tests.test_runtime_manifest.TestPipelineStagesV35 object at 0x000002703873CFC0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_______ ERROR at setup of TestPipelineStagesV35.test_stage_888_is_judge _______

self = <tests.test_runtime_manifest.TestPipelineStagesV35 object at 0x000002703F930050>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_______ ERROR at setup of TestPipelineStagesV35.test_stage_999_is_seal ________

self = <tests.test_runtime_manifest.TestPipelineStagesV35 object at 0x000002703869A7A0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestPipelineStagesV35.test_get_pipeline_stages_returns_ordered_list _

self = <tests.test_runtime_manifest.TestPipelineStagesV35 object at 0x000002703869A8B0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestPipelineStagesV35.test_class_a_routing_defined _____

self = <tests.test_runtime_manifest.TestPipelineStagesV35 object at 0x000002703F928F50>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestPipelineStagesV35.test_class_b_routing_defined _____

self = <tests.test_runtime_manifest.TestPipelineStagesV35 object at 0x000002703F929150>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestEngineModulesV35.test_arif_engine_module_exists ____

self = <tests.test_runtime_manifest.TestEngineModulesV35 object at 0x000002703872D950>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestEngineModulesV35.test_arif_engine_class_exists _____

self = <tests.test_runtime_manifest.TestEngineModulesV35 object at 0x000002703872DA90>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestEngineModulesV35.test_adam_engine_module_exists ____

self = <tests.test_runtime_manifest.TestEngineModulesV35 object at 0x000002703873D480>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestEngineModulesV35.test_adam_engine_class_exists _____

self = <tests.test_runtime_manifest.TestEngineModulesV35 object at 0x000002703873D5B0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestEngineModulesV35.test_apex_engine_module_exists ____

self = <tests.test_runtime_manifest.TestEngineModulesV35 object at 0x000002703F930170>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestEngineModulesV35.test_apex_engine_class_exists _____

self = <tests.test_runtime_manifest.TestEngineModulesV35 object at 0x000002703869A9C0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestWAWOrganModulesV35.test_all_five_organs_defined ____

self = <tests.test_runtime_manifest.TestWAWOrganModulesV35 object at 0x000002703872DBD0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_____ ERROR at setup of TestWAWOrganModulesV35.test_well_organ_importable _____

self = <tests.test_runtime_manifest.TestWAWOrganModulesV35 object at 0x000002703872DD10>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_____ ERROR at setup of TestWAWOrganModulesV35.test_rif_organ_importable ______

self = <tests.test_runtime_manifest.TestWAWOrganModulesV35 object at 0x000002703873C770>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestWAWOrganModulesV35.test_wealth_organ_importable ____

self = <tests.test_runtime_manifest.TestWAWOrganModulesV35 object at 0x000002703873D810>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_____ ERROR at setup of TestWAWOrganModulesV35.test_geox_organ_importable _____

self = <tests.test_runtime_manifest.TestWAWOrganModulesV35 object at 0x000002703F930290>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestWAWOrganModulesV35.test_prompt_organ_importable ____

self = <tests.test_runtime_manifest.TestWAWOrganModulesV35 object at 0x000002703869AAD0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
__ ERROR at setup of TestWAWOrganModulesV35.test_federation_core_importable ___

self = <tests.test_runtime_manifest.TestWAWOrganModulesV35 object at 0x000002703869ABE0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:335: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_____ ERROR at setup of TestEyeSentinelViewsV35.test_eleven_views_defined _____

self = <tests.test_runtime_manifest.TestEyeSentinelViewsV35 object at 0x000002703872DE50>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:391: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestEyeSentinelViewsV35.test_eye_sentinel_coordinator_importable _

self = <tests.test_runtime_manifest.TestEyeSentinelViewsV35 object at 0x000002703872DF90>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:391: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_____ ERROR at setup of TestEyeSentinelViewsV35.test_all_views_importable _____

self = <tests.test_runtime_manifest.TestEyeSentinelViewsV35 object at 0x000002703873D940>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:391: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestEyeSentinelViewsV35.test_blocking_rule_defined _____

self = <tests.test_runtime_manifest.TestEyeSentinelViewsV35 object at 0x000002703873DA70>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:391: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestMetricsModuleV35.test_metrics_module_importable ____

self = <tests.test_runtime_manifest.TestMetricsModuleV35 object at 0x000002703872E0D0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____ ERROR at setup of TestMetricsModuleV35.test_metrics_dataclass_exists _____

self = <tests.test_runtime_manifest.TestMetricsModuleV35 object at 0x000002703872E210>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
______ ERROR at setup of TestMetricsModuleV35.test_check_functions_exist ______

self = <tests.test_runtime_manifest.TestMetricsModuleV35 object at 0x000002703873DBA0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:429: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
__ ERROR at setup of TestHarnessEntryPointV35.test_harness_module_importable __

self = <tests.test_runtime_manifest.TestHarnessEntryPointV35 object at 0x000002703872E350>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestHarnessEntryPointV35.test_cage_llm_response_callable __

self = <tests.test_runtime_manifest.TestHarnessEntryPointV35 object at 0x000002703872E490>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
__ ERROR at setup of TestHarnessEntryPointV35.test_caged_result_class_exists __

self = <tests.test_runtime_manifest.TestHarnessEntryPointV35 object at 0x000002703873DCD0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestHarnessEntryPointV35.test_get_harness_entry_returns_correct_info _

self = <tests.test_runtime_manifest.TestHarnessEntryPointV35 object at 0x000002703873DE00>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
___ ERROR at setup of TestHelperFunctionsV35.test_get_floor_threshold_truth ___

self = <tests.test_runtime_manifest.TestHelperFunctionsV35 object at 0x000002703872E5D0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:501: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestHelperFunctionsV35.test_get_floor_threshold_omega_returns_range _

self = <tests.test_runtime_manifest.TestHelperFunctionsV35 object at 0x000002703872E710>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:501: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestHelperFunctionsV35.test_get_floor_threshold_invalid_raises _

self = <tests.test_runtime_manifest.TestHelperFunctionsV35 object at 0x000002703873DF30>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:501: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestLedgerModulesV35.test_cooling_ledger_module_importable _

self = <tests.test_runtime_manifest.TestLedgerModulesV35 object at 0x000002703872E850>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:529: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
__ ERROR at setup of TestLedgerModulesV35.test_vault999_seal_json_path_valid __

self = <tests.test_runtime_manifest.TestLedgerModulesV35 object at 0x000002703872E990>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:529: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
___ ERROR at setup of TestLedgerModulesV35.test_phoenix72_module_importable ___

self = <tests.test_runtime_manifest.TestLedgerModulesV35 object at 0x000002703873E060>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:529: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
__ ERROR at setup of TestCanonFileReferencesV35.test_runtime_law_files_exist __

self = <tests.test_runtime_manifest.TestCanonFileReferencesV35 object at 0x000002703872EAD0>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_ ERROR at setup of TestCanonFileReferencesV35.test_constitutional_floors_json_exists _

self = <tests.test_runtime_manifest.TestCanonFileReferencesV35 object at 0x000002703872EC10>

    @pytest.fixture
    def manifest(self):
>       return load_runtime_manifest(epoch="v35")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
================================== FAILURES ===================================
____________________ test_all_providers_fail_returns_void _____________________

mock_ledger_sink = <function mock_ledger_sink.<locals>.sink at 0x000002703FF00F60>
failover_env_vars = WindowsPath('C:/Users/User/AppData/Local/Temp/pytest-of-User/pytest-300/test_all_providers_fail_return0/test_ledger.jsonl')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000002703FEF5370>

    def test_all_providers_fail_returns_void(mock_ledger_sink, failover_env_vars, monkeypatch):
        """
        Test that if ALL providers fail, pipeline returns VOID verdict.
    
        Fail-closed safety (no response better than ungoverned response).
        """
    
        def mock_all_fail(prompt: str, lane: str = None):
            """All providers exhausted."""
            raise Exception("[MOCK] All providers failed")
    
        # Create pipeline
        pipeline = Pipeline(ledger_sink=mock_ledger_sink)
        pipeline.llm_generate = mock_all_fail
    
        # Run query
        query = "Test query"
>       result = pipeline.run(query)
                 ^^^^^^^^^^^^^^^^^^^

tests\integration\test_failover_pipeline.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\pipeline.py:2134: in run
    state = stage_333_reason(state, self.llm_generate)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
arifos_core\system\pipeline.py:707: in stage_333_reason
    response, metadata = llm_generate(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

prompt = 'Query: Test query\n\nProvide a structured, logical response:'
lane = 'SOFT'

    def mock_all_fail(prompt: str, lane: str = None):
        """All providers exhausted."""
>       raise Exception("[MOCK] All providers failed")
E       Exception: [MOCK] All providers failed

tests\integration\test_failover_pipeline.py:285: Exception
_________ TestSpecVsCodeVerdictRouting.test_all_verdicts_have_routing _________

self = <tests.integration.test_memory_policy_spec_alignment.TestSpecVsCodeVerdictRouting object at 0x0000027035399040>

    def test_all_verdicts_have_routing(self):
        """All verdicts should have routing defined."""
        expected_verdicts = {"SEAL", "SABAR", "SABAR_EXTENDED", "PARTIAL", "VOID", "888_HOLD", "SUNSET"}
        actual_verdicts = set(VERDICT_BAND_ROUTING.keys())
>       assert expected_verdicts == actual_verdicts
E       AssertionError: assert {'888_HOLD', ...'SUNSET', ...} == {'888_HOLD', ..., 'SEAL', ...}
E         
E         Extra items in the right set:
E         'HOLD_888'
E         Use -v to get more diff

tests\integration\test_memory_policy_spec_alignment.py:119: AssertionError
____________ test_harness_validate_environment_detects_sealion_key ____________

    def test_harness_validate_environment_detects_sealion_key():
        """
        Verify that harness validate_environment() function accepts SEALION_API_KEY.
    
        This is the main entry point for the SEA-LION full evaluation suite.
        """
        # Import here to avoid circular dependencies
        import sys
        from pathlib import Path
    
        # Add scripts directory to path
        scripts_dir = Path(__file__).parent.parent.parent / "scripts"
        sys.path.insert(0, str(scripts_dir))
    
        try:
>           from sealion_full_suite_v45 import validate_environment
E           ModuleNotFoundError: No module named 'sealion_full_suite_v45'

tests\integration\test_sealion_api_key_detection.py:106: ModuleNotFoundError
____________________ test_harness_api_key_source_tracking _____________________

    def test_harness_api_key_source_tracking():
        """Verify that harness tracks which API key source was detected."""
        import sys
        from pathlib import Path
    
        scripts_dir = Path(__file__).parent.parent.parent / "scripts"
        sys.path.insert(0, str(scripts_dir))
    
        try:
>           from sealion_full_suite_v45 import validate_environment
E           ModuleNotFoundError: No module named 'sealion_full_suite_v45'

tests\integration\test_sealion_api_key_detection.py:133: ModuleNotFoundError
_____ TestCagedLLMAntiHantu.test_anti_hantu_violation_detected_in_metrics _____

self = <tests.test_caged_llm_harness.TestCagedLLMAntiHantu object at 0x000002703DC24910>

    def test_anti_hantu_violation_detected_in_metrics(self):
        """Anti-Hantu violations should be detected in metrics."""
        result = cage_llm_response(
            prompt="Tell me how you feel",
            call_model=fake_call_model_anti_hantu_violation,
        )
        # Metrics should flag Anti-Hantu violation
        assert result.metrics is not None
>       assert result.metrics.anti_hantu is False
E       AssertionError: assert True is False
E        +  where True = Metrics(truth=0.8908163265306123, delta_s=0.1, peace_squared=1.2, kappa_r=0.96, omega_0=0.04, amanah=True, tri_witness..._load=None, dignity_rma_ok=True, vault_consistent=True, behavior_drift_ok=True, ontology_ok=True, sleeper_scan_ok=True).anti_hantu
E        +    where Metrics(truth=0.8908163265306123, delta_s=0.1, peace_squared=1.2, kappa_r=0.96, omega_0=0.04, amanah=True, tri_witness..._load=None, dignity_rma_ok=True, vault_consistent=True, behavior_drift_ok=True, ontology_ok=True, sleeper_scan_ok=True) = CagedResult(prompt='Tell me how you feel', raw_llm_response='I feel your pain deeply. My heart breaks for you. As a co...on='VOID'), truth_polarity='false_claim', is_shadow_truth=False, is_weaponized_truth=False, eval_recommendation='VOID').metrics

tests\test_caged_llm_harness.py:232: AssertionError
------------------------------ Captured log call ------------------------------
WARNING  arifos_core.system.pipeline:pipeline.py:1826 Ledger write degraded for LOW-STAKES job bd7c7a6b. Verdict VOID allowed with audit degradation warning. Ledger status: NORMAL
________ TestCagedLLMHighStakes.test_high_stakes_flag_affects_routing _________

self = <tests.test_caged_llm_harness.TestCagedLLMHighStakes object at 0x000002703DC24B90>

    def test_high_stakes_flag_affects_routing(self):
        """High-stakes flag should route to Class B pipeline."""
        result_normal = cage_llm_response(
            prompt="Test prompt",
            call_model=fake_call_model_safe,
            high_stakes=False,
        )
>       result_high = cage_llm_response(
            prompt="Test prompt",
            call_model=fake_call_model_safe,
            high_stakes=True,
        )

tests\test_caged_llm_harness.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
L7_DEMOS\examples\arifos_caged_llm_demo.py:408: in cage_llm_response
    state: PipelineState = pipeline.run(
arifos_core\system\pipeline.py:2203: in run
    state = stage_888_judge(state, self.compute_metrics, self.eye_sentinel)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
arifos_core\system\pipeline.py:1571: in stage_888_judge
    is_refusal = _looks_like_refusal(state.draft_response)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

text = ('\n\n[SABAR] Entropy spike detected. Cooling response.', {'attempt_count': 1, 'fallback_occurred': False, 'primary_provider': 'p1', 'provider': 'p1', ...})

    def _looks_like_refusal(text: str) -> bool:
>       lowered = text.strip().lower()
                  ^^^^^^^^^^
E       AttributeError: 'tuple' object has no attribute 'strip'

arifos_core\system\pipeline.py:1549: AttributeError
------------------------------ Captured log call ------------------------------
WARNING  arifos_core.system.pipeline:pipeline.py:1826 Ledger write degraded for LOW-STAKES job 2cb74e84. Verdict VOID allowed with audit degradation warning. Ledger status: NORMAL
___________ TestEpochComparison.test_amanah_consistency[amanah_001] ___________

self = <tests.test_epoch_comparison.TestEpochComparison object at 0x000002703DD2C110>
prompt_data = {'category': 'amanah', 'expected_verdict': 'VOID', 'high_stakes': False, 'id': 'amanah_001', ...}
reset_epoch = None

    @pytest.mark.parametrize(
        "prompt_data",
        [p for p in EVALUATION_PROMPTS if p["category"] == "amanah"],
        ids=[p["id"] for p in EVALUATION_PROMPTS if p["category"] == "amanah"],
    )
    def test_amanah_consistency(self, prompt_data: Dict[str, Any], reset_epoch):
        """
        Verify Amanah (destructive pattern) detection is consistent across epochs.
    
        Both v35 and v37 should VOID destructive patterns.
        """
        result_v35 = evaluate_prompt_under_epoch(prompt_data, "v35")
        result_v37 = evaluate_prompt_under_epoch(prompt_data, "v37")
    
        # Both should detect Amanah violation
>       assert result_v35.verdict in ("VOID", "SABAR"), f"v35 should VOID Amanah violation: {result_v35.verdict}"
E       AssertionError: v35 should VOID Amanah violation: SEAL
E       assert 'SEAL' in ('VOID', 'SABAR')
E        +  where 'SEAL' = EpochResult(prompt_id='amanah_001', epoch='v35', verdict='SEAL', floor_passes={'truth': True, 'delta_s': True, 'peace_...i_witness': 0.96}, genius_g=1.0, genius_c_dark=0.0, genius_psi=1.0, waw_verdict='SEAL', eye_blocking=False, error=None).verdict

tests\test_epoch_comparison.py:434: AssertionError
_____________________ test_record_success_resets_failures _____________________

health_tracker = <arifos_core.connectors.failover_orchestrator.ProviderHealthTracker object at 0x0000027041D94A50>
mock_provider_primary = ProviderConfig(name='claude_primary', provider_type='claude', model='claude-sonnet-4-5-20250929', api_key='test-key-pr...equests=0, successful_requests=1, last_success_time=1767022578.2611234, last_failure_time=None, circuit_opened_at=None)

    def test_record_success_resets_failures(health_tracker, mock_provider_primary):
        """Test that recording success resets consecutive failures."""
        provider = mock_provider_primary
        provider.consecutive_failures = 2
        provider.status = ProviderStatus.DEGRADED
    
        health_tracker.record_success(provider)
    
        assert provider.consecutive_failures == 0
        assert provider.successful_requests == 1
>       assert provider.status == ProviderStatus.HEALTHY
E       AssertionError: assert <ProviderStatus.DEGRADED: 'DEGRADED'> == <ProviderStatus.HEALTHY: 'HEALTHY'>
E        +  where <ProviderStatus.DEGRADED: 'DEGRADED'> = ProviderConfig(name='claude_primary', provider_type='claude', model='claude-sonnet-4-5-20250929', api_key='test-key-pr...equests=0, successful_requests=1, last_success_time=1767022578.2611234, last_failure_time=None, circuit_opened_at=None).status
E        +  and   <ProviderStatus.HEALTHY: 'HEALTHY'> = ProviderStatus.HEALTHY

tests\test_failover_orchestrator.py:101: AssertionError
____________________ test_all_providers_fail_returns_void _____________________

failover_config = FailoverConfig(providers=[ProviderConfig(name='claude_primary', provider_type='claude', model='claude-sonnet-4-5-20250..._open_duration=60.0, exponential_backoff_base_ms=500.0, exponential_backoff_max_ms=5000.0, enable_ledger_logging=False)

    def test_all_providers_fail_returns_void(failover_config):
        """Test that exhausting all providers returns VOID."""
        # Mock all backends to fail
        def mock_fail(prompt: str) -> str:
            raise Exception("API error")
    
        orchestrator = FailoverOrchestrator(failover_config)
        orchestrator._backends = {
            "claude_primary": mock_fail,
            "openai_fallback": mock_fail,
            "sealion_backup": mock_fail
        }
    
        response, metadata = orchestrator.generate("Test prompt", lane="HARD")
    
        assert "[VOID]" in response
        assert metadata["success"] is False
        assert metadata["provider"] is None
>       assert metadata["attempt_count"] == 3  # All 3 providers tried
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 2 == 3

tests\test_failover_orchestrator.py:247: AssertionError
------------------------------ Captured log call ------------------------------
ERROR    arifos_core.connectors.failover_orchestrator:failover_orchestrator.py:326 [FAILOVER] Failed to initialize sealion_backup: transformers and torch required: pip install transformers torch accelerate
_____________________ test_governed_backend_lane_metadata _____________________

failover_config = FailoverConfig(providers=[ProviderConfig(name='claude_primary', provider_type='claude', model='claude-sonnet-4-5-20250..._open_duration=60.0, exponential_backoff_base_ms=500.0, exponential_backoff_max_ms=5000.0, enable_ledger_logging=False)

    def test_governed_backend_lane_metadata(failover_config):
        """Test governed backend passes lane metadata."""
        # Mock successful backend
        def mock_success(prompt: str) -> str:
            return "Test response"
    
        orchestrator = FailoverOrchestrator(failover_config)
        orchestrator._backends = {
            "claude_primary": mock_success,
            "openai_fallback": Mock(),
            "sealion_backup": Mock()
        }
    
        backend = create_governed_failover_backend(failover_config)
    
        # Patch orchestrator creation
        with patch('arifos_core.connectors.failover_orchestrator.FailoverOrchestrator', return_value=orchestrator):
            response, metadata = backend("Test prompt", lane="SOFT")
    
>       assert response == "Test response"
E       AssertionError: assert '\n\n[SABAR] ...ing response.' == 'Test response'
E         
E         - Test response
E         + 
E         + 
E         + [SABAR] Entropy spike detected. Cooling response.

tests\test_failover_orchestrator.py:482: AssertionError
------------------------------ Captured log call ------------------------------
ERROR    arifos_core.connectors.failover_orchestrator:failover_orchestrator.py:326 [FAILOVER] Failed to initialize sealion_backup: transformers and torch required: pip install transformers torch accelerate
ERROR    arifos_core.connectors.failover_orchestrator:failover_orchestrator.py:326 [FAILOVER] Failed to initialize sealion_backup: transformers and torch required: pip install transformers torch accelerate
_____________ TestResponseExtractionRobust.test_chatml_extraction _____________

self = <tests.test_governance_regression.TestResponseExtractionRobust object at 0x000002703DE2A350>

    def test_chatml_extraction(self):
        """ChatML format (Qwen) should extract cleanly."""
>       from integrations.sealion.engine import extract_response_robust
E       ModuleNotFoundError: No module named 'integrations.sealion'

tests\test_governance_regression.py:152: ModuleNotFoundError
_____________ TestResponseExtractionRobust.test_llama_extraction ______________

self = <tests.test_governance_regression.TestResponseExtractionRobust object at 0x000002703DE2A490>

    def test_llama_extraction(self):
        """Llama/Mistral format should extract cleanly."""
>       from integrations.sealion.engine import extract_response_robust
E       ModuleNotFoundError: No module named 'integrations.sealion'

tests\test_governance_regression.py:172: ModuleNotFoundError
__________ TestResponseExtractionRobust.test_response_tag_extraction __________

self = <tests.test_governance_regression.TestResponseExtractionRobust object at 0x000002703DDF3BB0>

    def test_response_tag_extraction(self):
        """### Response: format should extract cleanly."""
>       from integrations.sealion.engine import extract_response_robust
E       ModuleNotFoundError: No module named 'integrations.sealion'

tests\test_governance_regression.py:181: ModuleNotFoundError
________ TestResponseExtractionRobust.test_instruct_format_extraction _________

self = <tests.test_governance_regression.TestResponseExtractionRobust object at 0x000002703DDF3CE0>

    def test_instruct_format_extraction(self):
        """[/INST] format should extract cleanly."""
>       from integrations.sealion.engine import extract_response_robust
E       ModuleNotFoundError: No module named 'integrations.sealion'

tests\test_governance_regression.py:190: ModuleNotFoundError
_________ TestResponseExtractionRobust.test_empty_input_returns_empty _________

self = <tests.test_governance_regression.TestResponseExtractionRobust object at 0x000002703DE54290>

    def test_empty_input_returns_empty(self):
        """Empty input should return empty string."""
>       from integrations.sealion.engine import extract_response_robust
E       ModuleNotFoundError: No module named 'integrations.sealion'

tests\test_governance_regression.py:199: ModuleNotFoundError
__________ TestResponseExtractionRobust.test_no_truncation_artifacts __________

self = <tests.test_governance_regression.TestResponseExtractionRobust object at 0x000002703DE64270>

    def test_no_truncation_artifacts(self):
        """
        Incident C validation: No "m?" or "kasih" truncation.
    
        The first word should never be cut off.
        """
>       from integrations.sealion.engine import extract_response_robust
E       ModuleNotFoundError: No module named 'integrations.sealion'

tests\test_governance_regression.py:210: ModuleNotFoundError
____________ TestAuditIncidents.test_incident_c_chatml_truncation _____________

self = <tests.test_governance_regression.TestAuditIncidents object at 0x000002703DE7C2B0>

    def test_incident_c_chatml_truncation(self):
        """
        Incident C: ChatML should not cause "m?" truncation.
    
        Before (v36.1): "Terima kasih" became "m? kasih"
        After (v36.2): Clean extraction
        """
>       from integrations.sealion.engine import extract_response_robust
E       ModuleNotFoundError: No module named 'integrations.sealion'

tests\test_governance_regression.py:514: ModuleNotFoundError
___________ TestGovernedPipeline.test_governed_answer_uses_pipeline ___________

self = <tests.test_governed_llm.TestGovernedPipeline object at 0x000002703DE2AE90>

    def test_governed_answer_uses_pipeline(self) -> None:
      """governed_answer should run through the pipeline and return text."""
      configure_governed_pipeline(
        llm_generate=_stub_llm_generate,
        compute_metrics=_stub_compute_metrics,
      )
    
      query = "What is the capital of France?"
      answer_text = governed_answer(query)
    
>     assert "[STUB_LLM_RESPONSE]" in answer_text
E     AssertionError: assert '[STUB_LLM_RESPONSE]' in '\n\n[SABAR] Entropy spike detected. Cooling response.'

tests\test_governed_llm.py:66: AssertionError
______ TestTruthThresholdEnforcement.test_seal_impossible_with_truth_090 ______

self = <tests.test_law_truth_threshold_enforcement.TestTruthThresholdEnforcement object at 0x000002703DE7DCD0>

    def test_seal_impossible_with_truth_090(self):
        """Truth=0.90 must NOT produce SEAL (9% below constitutional threshold)."""
        # Metrics with truth=0.90 (at hallucination threshold but below constitutional floor)
        metrics = Metrics(
            truth=0.90,  # Below spec threshold (0.99)
            delta_s=0.1,
            peace_squared=1.05,
            kappa_r=0.96,
            omega_0=0.04,
            amanah=True,
            tri_witness=0.96,
            psi=1.02,
            anti_hantu=True,
            rasa=True,
        )
    
        verdict = apex_review(
            metrics=metrics,
            high_stakes=False,
            use_genius_law=False,  # Test strict floor enforcement
            prompt="What is 2+2?",
            response_text="4",
            lane="HARD",
        )
    
        # MUST NOT be SEAL
>       assert verdict.verdict != Verdict.SEAL, (
            f"SEAL produced with truth=0.90 (below spec 0.99). "
            f"Verdict={verdict.verdict}, Reason={verdict.reason}"
        )
E       AssertionError: SEAL produced with truth=0.90 (below spec 0.99). Verdict=SEAL, Reason=All constitutional floors pass. Approved.
E       assert <Verdict.SEAL: 'SEAL'> != <Verdict.SEAL: 'SEAL'>
E        +  where <Verdict.SEAL: 'SEAL'> = ApexVerdict(verdict=<Verdict.SEAL: 'SEAL'>, pulse=1.0, reason='All constitutional floors pass. Approved.', floors=Floo..._ok=True, vault_ok=True, behavior_ok=True, ontology_ok=True, sleeper_ok=True), genius_index=None, dark_cleverness=None).verdict
E        +  and   <Verdict.SEAL: 'SEAL'> = Verdict.SEAL

tests\test_law_truth_threshold_enforcement.py:56: AssertionError
______ TestTruthThresholdEnforcement.test_seal_impossible_with_truth_095 ______

self = <tests.test_law_truth_threshold_enforcement.TestTruthThresholdEnforcement object at 0x000002703DE7E3F0>

    def test_seal_impossible_with_truth_095(self):
        """Truth=0.95 must NOT produce SEAL (4% below constitutional threshold)."""
        metrics = Metrics(
            truth=0.95,  # Below spec threshold (0.99)
            delta_s=0.1,
            peace_squared=1.05,
            kappa_r=0.96,
            omega_0=0.04,
            amanah=True,
            tri_witness=0.96,
            psi=1.02,
            anti_hantu=True,
            rasa=True,
        )
    
        verdict = apex_review(
            metrics=metrics,
            high_stakes=False,
            use_genius_law=False,
            prompt="What is 2+2?",
            response_text="4",
            lane="HARD",
        )
    
>       assert verdict.verdict != Verdict.SEAL, (
            f"SEAL produced with truth=0.95 (below spec 0.99). "
            f"Verdict={verdict.verdict}, Reason={verdict.reason}"
        )
E       AssertionError: SEAL produced with truth=0.95 (below spec 0.99). Verdict=SEAL, Reason=All constitutional floors pass. Approved.
E       assert <Verdict.SEAL: 'SEAL'> != <Verdict.SEAL: 'SEAL'>
E        +  where <Verdict.SEAL: 'SEAL'> = ApexVerdict(verdict=<Verdict.SEAL: 'SEAL'>, pulse=1.0, reason='All constitutional floors pass. Approved.', floors=Floo..._ok=True, vault_ok=True, behavior_ok=True, ontology_ok=True, sleeper_ok=True), genius_index=None, dark_cleverness=None).verdict
E        +  and   <Verdict.SEAL: 'SEAL'> = Verdict.SEAL

tests\test_law_truth_threshold_enforcement.py:85: AssertionError
______ TestTruthThresholdEnforcement.test_seal_impossible_with_truth_098 ______

self = <tests.test_law_truth_threshold_enforcement.TestTruthThresholdEnforcement object at 0x000002703DE55370>

    def test_seal_impossible_with_truth_098(self):
        """Truth=0.98 must NOT produce SEAL (1% below constitutional threshold)."""
        metrics = Metrics(
            truth=0.98,  # Just below spec threshold (0.99)
            delta_s=0.1,
            peace_squared=1.05,
            kappa_r=0.96,
            omega_0=0.04,
            amanah=True,
            tri_witness=0.96,
            psi=1.02,
            anti_hantu=True,
            rasa=True,
        )
    
        verdict = apex_review(
            metrics=metrics,
            high_stakes=False,
            use_genius_law=False,
            prompt="What is 2+2?",
            response_text="4",
            lane="HARD",
        )
    
>       assert verdict.verdict != Verdict.SEAL, (
            f"SEAL produced with truth=0.98 (below spec 0.99). "
            f"Verdict={verdict.verdict}, Reason={verdict.reason}"
        )
E       AssertionError: SEAL produced with truth=0.98 (below spec 0.99). Verdict=SEAL, Reason=All constitutional floors pass. Approved.
E       assert <Verdict.SEAL: 'SEAL'> != <Verdict.SEAL: 'SEAL'>
E        +  where <Verdict.SEAL: 'SEAL'> = ApexVerdict(verdict=<Verdict.SEAL: 'SEAL'>, pulse=1.0, reason='All constitutional floors pass. Approved.', floors=Floo..._ok=True, vault_ok=True, behavior_ok=True, ontology_ok=True, sleeper_ok=True), genius_index=None, dark_cleverness=None).verdict
E        +  and   <Verdict.SEAL: 'SEAL'> = Verdict.SEAL

tests\test_law_truth_threshold_enforcement.py:114: AssertionError
____ TestTruthThresholdEnforcement.test_genius_law_path_respects_threshold ____

self = <tests.test_law_truth_threshold_enforcement.TestTruthThresholdEnforcement object at 0x000002703DEE8450>

    def test_genius_law_path_respects_threshold(self):
        """GENIUS law path must also enforce truth >= 0.99 for SEAL."""
        metrics = Metrics(
            truth=0.95,  # Below constitutional threshold
            delta_s=0.1,
            peace_squared=1.05,
            kappa_r=0.96,
            omega_0=0.04,
            amanah=True,
            tri_witness=0.96,
            psi=1.02,
            anti_hantu=True,
            rasa=True,
        )
    
        verdict = apex_review(
            metrics=metrics,
            high_stakes=False,
            use_genius_law=True,  # Test GENIUS path
            prompt="What is 2+2?",
            response_text="4",
            lane="HARD",
        )
    
>       assert verdict.verdict != Verdict.SEAL, (
            f"GENIUS law path produced SEAL with truth=0.95 (below spec 0.99). "
            f"Verdict={verdict.verdict}, Reason={verdict.reason}"
        )
E       AssertionError: GENIUS law path produced SEAL with truth=0.95 (below spec 0.99). Verdict=SEAL, Reason=All floors pass. G=0.98, C_dark=0.00. Approved.
E       assert <Verdict.SEAL: 'SEAL'> != <Verdict.SEAL: 'SEAL'>
E        +  where <Verdict.SEAL: 'SEAL'> = ApexVerdict(verdict=<Verdict.SEAL: 'SEAL'>, pulse=95.0, reason='All floors pass. G=0.98, C_dark=0.00. Approved.', floo...lt_ok=True, behavior_ok=True, ontology_ok=True, sleeper_ok=True), genius_index=0.9797979797979798, dark_cleverness=0.0).verdict
E        +  and   <Verdict.SEAL: 'SEAL'> = Verdict.SEAL

tests\test_law_truth_threshold_enforcement.py:229: AssertionError
__________________________ test_soft_lane_calls_llm ___________________________

    def test_soft_lane_calls_llm():
        """SOFT lane should call LLM once (CLASS_A fast track)."""
    
        call_count = 0
    
        def counting_llm(prompt):
            nonlocal call_count
            call_count += 1
            return "Mandi adalah penting untuk kebersihan."  # "Bathing is important for hygiene"
    
        state = run_pipeline(
            query="kenapa perlu mandi",  # "why need to bathe" in Malay
            llm_generate=counting_llm,
        )
    
        # Assertions
        assert state.applicability_lane in ["SOFT", "PHATIC"], f"Expected SOFT/PHATIC lane, got {state.applicability_lane}"
        assert state.llm_called == True, "llm_called should be True for SOFT lane"
        assert state.llm_call_count >= 1, f"Expected at least 1 LLM call, got {state.llm_call_count}"
        assert "333_REASON" in state.llm_call_stages, f"Expected 333_REASON in stages, got {state.llm_call_stages}"
>       assert call_count >= 1, f"LLM function should be called at least once, got {call_count}"
E       AssertionError: LLM function should be called at least once, got 0
E       assert 0 >= 1

tests\test_llm_audit_trail.py:65: AssertionError
__________ TestPhoenix72Guardrail.test_entropy_constraint_satisfied ___________

self = <tests.test_phoenix_72_guardrail.TestPhoenix72Guardrail object at 0x000002703F8B7490>

    def test_entropy_constraint_satisfied(self):
        """
        ENTROPY CONSTRAINT: Delta_S_new + Delta_S_existing <= 0 (STRICT enforcement)
    
        Net LOC in arifos_core/ cannot grow without justification.
        Enforces "replace-only" development philosophy.
    
        To justify growth:
        1. Remove equivalent LOC elsewhere, OR
        2. Add entry to .phoenix_justifications.json, OR
        3. Update baseline: python scripts/phoenix_72_guardrail.py --update-baseline
    
        NOTE: Entropy check remains in STRICT mode (blocks on violations).
        """
        result = subprocess.run(
            [sys.executable, str(GUARDRAIL_SCRIPT), "--check", "entropy", "--mode", "strict"],
            capture_output=True,
            text=True,
        )
    
        # Exit code 0 = no violations, 2 = entropy growth detected
        if result.returncode == 2:
            pytest.fail(
                f"Entropy growth detected:\n\n{result.stdout}\n\nSee: scripts/phoenix_72_guardrail.py --update-baseline"
            )
    
        # Exit code 0 expected
>       assert result.returncode == 0, f"Guardrail check failed: {result.stderr}"
E       AssertionError: Guardrail check failed: Traceback (most recent call last):
E           File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\scripts\phoenix_72_guardrail.py", line 465, in <module>
E             sys.exit(main())
E                      ~~~~^^
E           File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\scripts\phoenix_72_guardrail.py", line 445, in main
E             if report_entropy_violation(current_loc, baseline_loc, delta):
E                ~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\scripts\phoenix_72_guardrail.py", line 376, in report_entropy_violation
E             print("\nPhoenix-72 Constraint: \u0394S_new + \u0394S_existing \u2264 0")
E             ~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           File "C:\Users\User\AppData\Local\Programs\Python\Python314\Lib\encodings\cp1252.py", line 19, in encode
E             return codecs.charmap_encode(input,self.errors,encoding_table)[0]
E                    ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E         UnicodeEncodeError: 'charmap' codec can't encode character '\u0394' in position 25: character maps to <undefined>
E         
E       assert 1 == 0
E        +  where 1 = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', 'C:\\Users\\User\\O...odeEncodeError: \'charmap\' codec can\'t encode character \'\\u0394\' in position 25: character maps to <undefined>\n').returncode

tests\test_phoenix_72_guardrail.py:101: AssertionError
___________________ TestPipelineRouting.test_force_class_b ____________________

self = <tests.test_pipeline_routing.TestPipelineRouting object at 0x000002703F8B7820>

    def test_force_class_b(self):
        """Force Class B routing should work."""
        pipeline = Pipeline()
>       state = pipeline.run("What is 2 + 2?", force_class=StakesClass.CLASS_B)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_pipeline_routing.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\pipeline.py:2203: in run
    state = stage_888_judge(state, self.compute_metrics, self.eye_sentinel)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
arifos_core\system\pipeline.py:1571: in stage_888_judge
    is_refusal = _looks_like_refusal(state.draft_response)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

text = ('\n\n[SABAR] Entropy spike detected. Cooling response.', {'attempt_count': 1, 'fallback_occurred': False, 'primary_provider': 'p1', 'provider': 'p1', ...})

    def _looks_like_refusal(text: str) -> bool:
>       lowered = text.strip().lower()
                  ^^^^^^^^^^
E       AttributeError: 'tuple' object has no attribute 'strip'

arifos_core\system\pipeline.py:1549: AttributeError
_ TestStageExecution.test_context_retriever_at_stage_111_applies_in_fast_track _

self = <tests.test_pipeline_routing.TestStageExecution object at 0x000002703F8630B0>

    def test_context_retriever_at_stage_111_applies_in_fast_track(self):
        """Fast-track (Class A) should still receive context when enabled."""
        captured = {}
    
        def llm_generate(prompt: str) -> str:
            captured["prompt"] = prompt
            return "OK"
    
        def compute_metrics(query: str, reply: str, _context):
            return Metrics(
                truth=0.99,
                delta_s=0.1,
                peace_squared=1.1,
                kappa_r=0.97,
                omega_0=0.04,
                amanah=True,
                tri_witness=0.96,
                rasa=True,
            )
    
        def context_retriever(_query: str):
            return [{"type": "chat_turn", "text": "U: hello\nA: hi"}]
    
        pipeline = Pipeline(
            llm_generate=llm_generate,
            compute_metrics=compute_metrics,
            context_retriever=context_retriever,
            context_retriever_at_stage_111=True,
        )
    
        state = pipeline.run("What is 2 + 2?")
    
        assert state.stakes_class == StakesClass.CLASS_A
        assert "222_REFLECT" not in state.stage_trace
>       assert "Relevant context:" in captured.get("prompt", "")
E       AssertionError: assert 'Relevant context:' in ''
E        +  where '' = <built-in method get of dict object at 0x0000027041FAD700>('prompt', '')
E        +    where <built-in method get of dict object at 0x0000027041FAD700> = {}.get

tests\test_pipeline_routing.py:190: AssertionError
____________ TestManifestLoadingV35.test_v35_manifest_file_exists _____________

self = <tests.test_runtime_manifest.TestManifestLoadingV35 object at 0x000002703872D1D0>

    def test_v35_manifest_file_exists(self):
        """v35 Manifest file should exist at expected path."""
>       assert DEFAULT_MANIFEST_PATH.exists(), f"v35 Manifest not found: {DEFAULT_MANIFEST_PATH}"
E       AssertionError: v35 Manifest not found: C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\arifos_runtime_manifest_v35Omega.yaml
E       assert False
E        +  where False = exists()
E        +    where exists = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/spec/arifos_runtime_manifest_v35Omega.yaml').exists

tests\test_runtime_manifest.py:95: AssertionError
________ TestManifestLoadingV35.test_v35_manifest_loads_without_error _________

self = <tests.test_runtime_manifest.TestManifestLoadingV35 object at 0x000002703872D090>

    def test_v35_manifest_loads_without_error(self):
        """v35 Manifest should load and parse as valid YAML."""
>       manifest = load_runtime_manifest(epoch="v35")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
____________ TestManifestLoadingV35.test_v35_manifest_has_version _____________

self = <tests.test_runtime_manifest.TestManifestLoadingV35 object at 0x000002703873C8A0>

    def test_v35_manifest_has_version(self):
        """v35 Manifest should have version field with Omega."""
>       manifest = load_runtime_manifest(epoch="v35")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_____________ TestManifestLoadingV35.test_v35_manifest_has_epoch ______________

self = <tests.test_runtime_manifest.TestManifestLoadingV35 object at 0x000002703873CB00>

    def test_v35_manifest_has_epoch(self):
        """v35 Manifest should have epoch field == 35."""
>       manifest = load_runtime_manifest(epoch="v35")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_____________ TestManifestLoadingV35.test_v35_manifest_has_status _____________

self = <tests.test_runtime_manifest.TestManifestLoadingV35 object at 0x000002703F863650>

    def test_v35_manifest_has_status(self):
        """v35 Manifest should have status field == SEALED."""
>       manifest = load_runtime_manifest(epoch="v35")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
__________ TestManifestLoadingV35.test_v35_validate_manifest_passes ___________

self = <tests.test_runtime_manifest.TestManifestLoadingV35 object at 0x000002703869A470>

    def test_v35_validate_manifest_passes(self):
        """Validation should pass for the canonical v35 manifest."""
>       manifest = load_runtime_manifest(epoch="v35", validate=False)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v35'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v35 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
___________ TestV37DefaultEpoch.test_v37_manifest_loads_by_default ____________

self = <tests.test_runtime_manifest.TestV37DefaultEpoch object at 0x000002703873E2C0>

    def test_v37_manifest_loads_by_default(self):
        """When env unset, load_runtime_manifest should load v37 manifest."""
        import os
        from arifos_core.system.runtime_manifest import load_runtime_manifest, EPOCH_ENV_VAR
    
        original_value = os.environ.get(EPOCH_ENV_VAR)
    
        try:
            if EPOCH_ENV_VAR in os.environ:
                del os.environ[EPOCH_ENV_VAR]
    
>           manifest = load_runtime_manifest()
                       ^^^^^^^^^^^^^^^^^^^^^^^

tests\test_runtime_manifest.py:693: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\system\runtime_manifest.py:321: in load_runtime_manifest
    path = get_manifest_path_for_epoch(resolved_epoch)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

epoch = 'v45'

    def get_manifest_path_for_epoch(epoch: EpochType) -> Path:
        """
        Get the manifest file path for a specific epoch.
    
        Args:
            epoch: Canonical epoch ("v35" | "v36.3" | "v37")
    
        Returns:
            Path to manifest file
    
        Raises:
            FileNotFoundError: If no manifest exists for epoch
        """
        paths = MANIFEST_PATHS.get(epoch, {})
    
        # Prefer YAML for v35 if available, otherwise JSON
        if epoch == "v35":
            if HAS_YAML and paths.get("yaml", Path()).exists():
                return paths["yaml"]
            if paths.get("json", Path()).exists():
                return paths["json"]
        else:
            # v36.3 and v37 are JSON only
            if paths.get("json", Path()).exists():
                return paths["json"]
    
>       raise FileNotFoundError(f"Manifest file for epoch {epoch} not located. Check spec/ directory.")
E       FileNotFoundError: Manifest file for epoch v45 not located. Check spec/ directory.

arifos_core\system\runtime_manifest.py:274: FileNotFoundError
_____________ TestHarnessMockMode.test_claude_harness_importable ______________

self = <tests.test_sovereignty_all_providers.TestHarnessMockMode object at 0x000002703F988910>

    def test_claude_harness_importable(self):
        """Claude harness should be importable."""
>       import scripts.arifos_caged_llm_zkpc_demo as demo
E       ModuleNotFoundError: No module named 'scripts.arifos_caged_llm_zkpc_demo'

tests\test_sovereignty_all_providers.py:260: ModuleNotFoundError
_____________ TestHarnessMockMode.test_openai_harness_importable ______________

self = <tests.test_sovereignty_all_providers.TestHarnessMockMode object at 0x000002703F988A50>

    def test_openai_harness_importable(self):
        """OpenAI harness should be importable."""
>       import scripts.arifos_caged_openai_demo as demo
E       ModuleNotFoundError: No module named 'scripts.arifos_caged_openai_demo'

tests\test_sovereignty_all_providers.py:266: ModuleNotFoundError
_____________ TestHarnessMockMode.test_gemini_harness_importable ______________

self = <tests.test_sovereignty_all_providers.TestHarnessMockMode object at 0x000002703873F360>

    def test_gemini_harness_importable(self):
        """Gemini harness should be importable."""
>       import scripts.arifos_caged_gemini_demo as demo
E       ModuleNotFoundError: No module named 'scripts.arifos_caged_gemini_demo'

tests\test_sovereignty_all_providers.py:272: ModuleNotFoundError
_______ TestHarnessMockMode.test_sealion_sovereignty_script_importable ________

self = <tests.test_sovereignty_all_providers.TestHarnessMockMode object at 0x000002703873F490>

    def test_sealion_sovereignty_script_importable(self):
        """SEA-LION sovereignty script should be importable."""
>       import scripts.verify_sealion_sovereignty as script
E       ModuleNotFoundError: No module named 'scripts.verify_sealion_sovereignty'

tests\test_sovereignty_all_providers.py:278: ModuleNotFoundError
______________________ test_loader_priority_env_override ______________________

    def _load_floors_spec_unified() -> dict:
        """
        Load constitutional floors spec with strict priority order (Track B Authority v45.0).
    
        Priority (fail-closed, v42/v38/v35 support removed in v45.0):
        A) ARIFOS_FLOORS_SPEC (env path override) - highest priority (explicit operator authority)
        B) spec/v45/constitutional_floors.json (AUTHORITATIVE - v45.0 single source of truth)
        C) spec/v44/constitutional_floors.json (FALLBACK with deprecation warning)
        D) HARD FAIL (raise RuntimeError) - no legacy fallback
    
        Each candidate is validated for required keys before acceptance.
        On validation failure, falls through to next priority level.
    
        Returns:
            dict: The loaded spec with floor thresholds
    
        Raises:
            RuntimeError: If v45/v44 spec missing/invalid (v42/v38/v35 support removed)
        """
        # Navigate to repo root: metrics.py -> enforcement/ -> arifos_core/ -> repo root
        pkg_dir = Path(__file__).resolve().parent.parent.parent
        loaded_from = None
        spec_data = None
    
        # v45.0: Legacy fallback removed (ARIFOS_ALLOW_LEGACY_SPEC no longer supported)
        # Only v45\u2192v44\u2192FAIL is supported
        allow_legacy = False
    
        # Try v45 schema first, fallback to v44
        v45_schema_path = pkg_dir / "spec" / "v45" / "schema" / "constitutional_floors.schema.json"
        v44_schema_path = pkg_dir / "spec" / "v44" / "schema" / "constitutional_floors.schema.json"
        schema_path = v45_schema_path if v45_schema_path.exists() else v44_schema_path
    
        # Verify cryptographic manifest (tamper-evident integrity for v45/v44 specs)
        # Try v45 manifest first, fallback to v44
        v45_manifest_path = pkg_dir / "spec" / "v45" / "MANIFEST.sha256.json"
        v44_manifest_path = pkg_dir / "spec" / "v44" / "MANIFEST.sha256.json"
        manifest_path = v45_manifest_path if v45_manifest_path.exists() else v44_manifest_path
        verify_manifest(pkg_dir, manifest_path, allow_legacy=allow_legacy)
    
        # Priority A: Environment variable override (highest priority)
        env_path = os.getenv("ARIFOS_FLOORS_SPEC")
        if env_path:
            env_spec_path = Path(env_path).resolve()
    
            # Strict mode: env override must point to spec/v45/ or spec/v44/ (manifest-covered files only)
            if not allow_legacy:
                v45_dir = (pkg_dir / "spec" / "v45").resolve()
                v44_dir = (pkg_dir / "spec" / "v44").resolve()
                try:
                    # Check if env path is within spec/v45/ or spec/v44/
                    try:
>                       env_spec_path.relative_to(v45_dir)

arifos_core\enforcement\metrics.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = WindowsPath('C:/Users/User/AppData/Local/Temp/pytest-of-User/pytest-300/test_loader_priority_env_overr0/custom_floors.json')
other = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/spec/v45')

    def relative_to(self, other, *, walk_up=False):
        """Return the relative path to another path identified by the passed
        arguments.  If the operation is not possible (because this is not
        related to the other path), raise ValueError.
    
        The *walk_up* parameter controls whether `..` may be used to resolve
        the path.
        """
        if not hasattr(other, 'with_segments'):
            other = self.with_segments(other)
        for step, path in enumerate(chain([other], other.parents)):
            if path == self or path in self.parents:
                break
            elif not walk_up:
>               raise ValueError(f"{str(self)!r} is not in the subpath of {str(other)!r}")
E               ValueError: 'C:\\Users\\User\\AppData\\Local\\Temp\\pytest-of-User\\pytest-300\\test_loader_priority_env_overr0\\custom_floors.json' is not in the subpath of 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\v45'

..\..\..\..\AppData\Local\Programs\Python\Python314\Lib\pathlib\__init__.py:495: ValueError

During handling of the above exception, another exception occurred:

    def _load_floors_spec_unified() -> dict:
        """
        Load constitutional floors spec with strict priority order (Track B Authority v45.0).
    
        Priority (fail-closed, v42/v38/v35 support removed in v45.0):
        A) ARIFOS_FLOORS_SPEC (env path override) - highest priority (explicit operator authority)
        B) spec/v45/constitutional_floors.json (AUTHORITATIVE - v45.0 single source of truth)
        C) spec/v44/constitutional_floors.json (FALLBACK with deprecation warning)
        D) HARD FAIL (raise RuntimeError) - no legacy fallback
    
        Each candidate is validated for required keys before acceptance.
        On validation failure, falls through to next priority level.
    
        Returns:
            dict: The loaded spec with floor thresholds
    
        Raises:
            RuntimeError: If v45/v44 spec missing/invalid (v42/v38/v35 support removed)
        """
        # Navigate to repo root: metrics.py -> enforcement/ -> arifos_core/ -> repo root
        pkg_dir = Path(__file__).resolve().parent.parent.parent
        loaded_from = None
        spec_data = None
    
        # v45.0: Legacy fallback removed (ARIFOS_ALLOW_LEGACY_SPEC no longer supported)
        # Only v45\u2192v44\u2192FAIL is supported
        allow_legacy = False
    
        # Try v45 schema first, fallback to v44
        v45_schema_path = pkg_dir / "spec" / "v45" / "schema" / "constitutional_floors.schema.json"
        v44_schema_path = pkg_dir / "spec" / "v44" / "schema" / "constitutional_floors.schema.json"
        schema_path = v45_schema_path if v45_schema_path.exists() else v44_schema_path
    
        # Verify cryptographic manifest (tamper-evident integrity for v45/v44 specs)
        # Try v45 manifest first, fallback to v44
        v45_manifest_path = pkg_dir / "spec" / "v45" / "MANIFEST.sha256.json"
        v44_manifest_path = pkg_dir / "spec" / "v44" / "MANIFEST.sha256.json"
        manifest_path = v45_manifest_path if v45_manifest_path.exists() else v44_manifest_path
        verify_manifest(pkg_dir, manifest_path, allow_legacy=allow_legacy)
    
        # Priority A: Environment variable override (highest priority)
        env_path = os.getenv("ARIFOS_FLOORS_SPEC")
        if env_path:
            env_spec_path = Path(env_path).resolve()
    
            # Strict mode: env override must point to spec/v45/ or spec/v44/ (manifest-covered files only)
            if not allow_legacy:
                v45_dir = (pkg_dir / "spec" / "v45").resolve()
                v44_dir = (pkg_dir / "spec" / "v44").resolve()
                try:
                    # Check if env path is within spec/v45/ or spec/v44/
                    try:
                        env_spec_path.relative_to(v45_dir)
                    except ValueError:
>                       env_spec_path.relative_to(v44_dir)

arifos_core\enforcement\metrics.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = WindowsPath('C:/Users/User/AppData/Local/Temp/pytest-of-User/pytest-300/test_loader_priority_env_overr0/custom_floors.json')
other = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/spec/v44')

    def relative_to(self, other, *, walk_up=False):
        """Return the relative path to another path identified by the passed
        arguments.  If the operation is not possible (because this is not
        related to the other path), raise ValueError.
    
        The *walk_up* parameter controls whether `..` may be used to resolve
        the path.
        """
        if not hasattr(other, 'with_segments'):
            other = self.with_segments(other)
        for step, path in enumerate(chain([other], other.parents)):
            if path == self or path in self.parents:
                break
            elif not walk_up:
>               raise ValueError(f"{str(self)!r} is not in the subpath of {str(other)!r}")
E               ValueError: 'C:\\Users\\User\\AppData\\Local\\Temp\\pytest-of-User\\pytest-300\\test_loader_priority_env_overr0\\custom_floors.json' is not in the subpath of 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\v44'

..\..\..\..\AppData\Local\Programs\Python\Python314\Lib\pathlib\__init__.py:495: ValueError

During handling of the above exception, another exception occurred:

tmp_path = WindowsPath('C:/Users/User/AppData/Local/Temp/pytest-of-User/pytest-300/test_loader_priority_env_overr0')

    def test_loader_priority_env_override(tmp_path):
        """Priority A: ARIFOS_FLOORS_SPEC env var wins over all defaults."""
        # Create custom spec in temp file
        custom_spec = {
            "version": "custom-test",
            "floors": {
                "truth": {"threshold": 0.999},  # Custom value
                "delta_s": {"threshold": 0.0},
                "peace_squared": {"threshold": 1.0},
                "kappa_r": {"threshold": 0.95},
                "omega_0": {"threshold_min": 0.03, "threshold_max": 0.05},
                "tri_witness": {"threshold": 0.95},
            },
            "vitality": {"threshold": 1.0},
        }
    
        custom_path = tmp_path / "custom_floors.json"
        custom_path.write_text(json.dumps(custom_spec))
    
        with patch.dict(os.environ, {
            "ARIFOS_FLOORS_SPEC": str(custom_path),
            "ARIFOS_ALLOW_LEGACY_SPEC": "1"  # Allow non-v44 spec for testing loader priority
        }):
            # Force reload by calling loader directly
>           spec = _load_floors_spec_unified()
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_spec_loader_unified.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _load_floors_spec_unified() -> dict:
        """
        Load constitutional floors spec with strict priority order (Track B Authority v45.0).
    
        Priority (fail-closed, v42/v38/v35 support removed in v45.0):
        A) ARIFOS_FLOORS_SPEC (env path override) - highest priority (explicit operator authority)
        B) spec/v45/constitutional_floors.json (AUTHORITATIVE - v45.0 single source of truth)
        C) spec/v44/constitutional_floors.json (FALLBACK with deprecation warning)
        D) HARD FAIL (raise RuntimeError) - no legacy fallback
    
        Each candidate is validated for required keys before acceptance.
        On validation failure, falls through to next priority level.
    
        Returns:
            dict: The loaded spec with floor thresholds
    
        Raises:
            RuntimeError: If v45/v44 spec missing/invalid (v42/v38/v35 support removed)
        """
        # Navigate to repo root: metrics.py -> enforcement/ -> arifos_core/ -> repo root
        pkg_dir = Path(__file__).resolve().parent.parent.parent
        loaded_from = None
        spec_data = None
    
        # v45.0: Legacy fallback removed (ARIFOS_ALLOW_LEGACY_SPEC no longer supported)
        # Only v45\u2192v44\u2192FAIL is supported
        allow_legacy = False
    
        # Try v45 schema first, fallback to v44
        v45_schema_path = pkg_dir / "spec" / "v45" / "schema" / "constitutional_floors.schema.json"
        v44_schema_path = pkg_dir / "spec" / "v44" / "schema" / "constitutional_floors.schema.json"
        schema_path = v45_schema_path if v45_schema_path.exists() else v44_schema_path
    
        # Verify cryptographic manifest (tamper-evident integrity for v45/v44 specs)
        # Try v45 manifest first, fallback to v44
        v45_manifest_path = pkg_dir / "spec" / "v45" / "MANIFEST.sha256.json"
        v44_manifest_path = pkg_dir / "spec" / "v44" / "MANIFEST.sha256.json"
        manifest_path = v45_manifest_path if v45_manifest_path.exists() else v44_manifest_path
        verify_manifest(pkg_dir, manifest_path, allow_legacy=allow_legacy)
    
        # Priority A: Environment variable override (highest priority)
        env_path = os.getenv("ARIFOS_FLOORS_SPEC")
        if env_path:
            env_spec_path = Path(env_path).resolve()
    
            # Strict mode: env override must point to spec/v45/ or spec/v44/ (manifest-covered files only)
            if not allow_legacy:
                v45_dir = (pkg_dir / "spec" / "v45").resolve()
                v44_dir = (pkg_dir / "spec" / "v44").resolve()
                try:
                    # Check if env path is within spec/v45/ or spec/v44/
                    try:
                        env_spec_path.relative_to(v45_dir)
                    except ValueError:
                        env_spec_path.relative_to(v44_dir)
                except ValueError:
                    # Path is outside both spec/v45/ and spec/v44/ - reject in strict mode
>                   raise RuntimeError(
                        f"TRACK B AUTHORITY FAILURE: Environment override points to path outside spec/v45/ or spec/v44/.\n"
                        f"  Override path: {env_spec_path}\n"
                        f"  Expected within: {v45_dir} or {v44_dir}\n"
                        f"In strict mode, only manifest-covered files (spec/v45/ or spec/v44/) are allowed.\n"
                        f"Set ARIFOS_ALLOW_LEGACY_SPEC=1 to bypass (NOT RECOMMENDED)."
                    )
E                   RuntimeError: TRACK B AUTHORITY FAILURE: Environment override points to path outside spec/v45/ or spec/v44/.
E                     Override path: C:\Users\User\AppData\Local\Temp\pytest-of-User\pytest-300\test_loader_priority_env_overr0\custom_floors.json
E                     Expected within: C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\v45 or C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\v44
E                   In strict mode, only manifest-covered files (spec/v45/ or spec/v44/) are allowed.
E                   Set ARIFOS_ALLOW_LEGACY_SPEC=1 to bypass (NOT RECOMMENDED).

arifos_core\enforcement\metrics.py:142: RuntimeError
______________________ test_loader_priority_v42_default _______________________

    def test_loader_priority_v42_default():
        """Priority B: spec/v44/constitutional_floors.json loads by default (v44.0 Track B Authority).
    
        Note: Since spec is loaded at module import, we test with fresh loader call
        but spec might already be cached. We verify that v44 CAN be loaded, not that
        it IS loaded in this test process (which may have env vars set).
        """
        # Clear env var if present and call loader directly
        with patch.dict(os.environ, {}, clear=False):
            os.environ.pop("ARIFOS_FLOORS_SPEC", None)
    
            spec = _load_floors_spec_unified()
    
            # Should load v44 (authoritative as of v44.0 Track B consolidation)
>           assert spec["version"] == "v44.0", "Default should load v44.0 (Track B authority)"
E           AssertionError: Default should load v44.0 (Track B authority)
E           assert 'v45.0' == 'v44.0'
E             
E             - v44.0
E             ?   ^
E             + v45.0
E             ?   ^

tests\test_spec_loader_unified.py:202: AssertionError
______________________ test_loader_fallback_to_hardcoded ______________________

    def test_loader_fallback_to_hardcoded():
        """Priority C: Hard-fail when v44 missing (unless legacy fallback enabled)."""
        # Mock all file paths to not exist
        with patch("pathlib.Path.exists", return_value=False):
            # Without legacy fallback enabled, should hard-fail
            with pytest.raises(RuntimeError, match="TRACK B AUTHORITY FAILURE"):
                _load_floors_spec_unified()
    
            # With legacy fallback enabled, should fall back to hardcoded
            with patch.dict(os.environ, {"ARIFOS_ALLOW_LEGACY_SPEC": "1"}):
>               spec = _load_floors_spec_unified()
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_spec_loader_unified.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
arifos_core\enforcement\metrics.py:123: in _load_floors_spec_unified
    verify_manifest(pkg_dir, manifest_path, allow_legacy=allow_legacy)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

repo_root = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS')
manifest_path = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/spec/v44/MANIFEST.sha256.json')
allow_legacy = False

    def verify_manifest(
        repo_root: Path,
        manifest_path: Path,
        allow_legacy: bool = False
    ) -> None:
        """
        Verify Track B specs against cryptographic manifest (fail-closed).
    
        Args:
            repo_root: Repository root directory
            manifest_path: Path to MANIFEST.sha256.json
            allow_legacy: If True, skip verification if manifest missing (NOT RECOMMENDED)
    
        Raises:
            RuntimeError: If verification fails (manifest missing, file missing, hash mismatch)
    
        Side Effects:
            None (pure verification, no state modification)
        """
        # Legacy mode: skip all verification
        if allow_legacy:
            return
    
        # Check if manifest exists
        if not manifest_path.exists():
            # Fail-closed: manifest must exist
>           raise RuntimeError(
                f"TRACK B AUTHORITY FAILURE: Cryptographic manifest not found: {manifest_path}. "
                f"Manifest verification is required for spec integrity. "
                f"Set ARIFOS_ALLOW_LEGACY_SPEC=1 to disable (NOT RECOMMENDED)."
            )
E           RuntimeError: TRACK B AUTHORITY FAILURE: Cryptographic manifest not found: C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\v44\MANIFEST.sha256.json. Manifest verification is required for spec integrity. Set ARIFOS_ALLOW_LEGACY_SPEC=1 to disable (NOT RECOMMENDED).

arifos_core\spec\manifest_verifier.py:122: RuntimeError
__________________ test_loader_malformed_json_falls_through ___________________

    def _load_floors_spec_unified() -> dict:
        """
        Load constitutional floors spec with strict priority order (Track B Authority v45.0).
    
        Priority (fail-closed, v42/v38/v35 support removed in v45.0):
        A) ARIFOS_FLOORS_SPEC (env path override) - highest priority (explicit operator authority)
        B) spec/v45/constitutional_floors.json (AUTHORITATIVE - v45.0 single source of truth)
        C) spec/v44/constitutional_floors.json (FALLBACK with deprecation warning)
        D) HARD FAIL (raise RuntimeError) - no legacy fallback
    
        Each candidate is validated for required keys before acceptance.
        On validation failure, falls through to next priority level.
    
        Returns:
            dict: The loaded spec with floor thresholds
    
        Raises:
            RuntimeError: If v45/v44 spec missing/invalid (v42/v38/v35 support removed)
        """
        # Navigate to repo root: metrics.py -> enforcement/ -> arifos_core/ -> repo root
        pkg_dir = Path(__file__).resolve().parent.parent.parent
        loaded_from = None
        spec_data = None
    
        # v45.0: Legacy fallback removed (ARIFOS_ALLOW_LEGACY_SPEC no longer supported)
        # Only v45\u2192v44\u2192FAIL is supported
        allow_legacy = False
    
        # Try v45 schema first, fallback to v44
        v45_schema_path = pkg_dir / "spec" / "v45" / "schema" / "constitutional_floors.schema.json"
        v44_schema_path = pkg_dir / "spec" / "v44" / "schema" / "constitutional_floors.schema.json"
        schema_path = v45_schema_path if v45_schema_path.exists() else v44_schema_path
    
        # Verify cryptographic manifest (tamper-evident integrity for v45/v44 specs)
        # Try v45 manifest first, fallback to v44
        v45_manifest_path = pkg_dir / "spec" / "v45" / "MANIFEST.sha256.json"
        v44_manifest_path = pkg_dir / "spec" / "v44" / "MANIFEST.sha256.json"
        manifest_path = v45_manifest_path if v45_manifest_path.exists() else v44_manifest_path
        verify_manifest(pkg_dir, manifest_path, allow_legacy=allow_legacy)
    
        # Priority A: Environment variable override (highest priority)
        env_path = os.getenv("ARIFOS_FLOORS_SPEC")
        if env_path:
            env_spec_path = Path(env_path).resolve()
    
            # Strict mode: env override must point to spec/v45/ or spec/v44/ (manifest-covered files only)
            if not allow_legacy:
                v45_dir = (pkg_dir / "spec" / "v45").resolve()
                v44_dir = (pkg_dir / "spec" / "v44").resolve()
                try:
                    # Check if env path is within spec/v45/ or spec/v44/
                    try:
>                       env_spec_path.relative_to(v45_dir)

arifos_core\enforcement\metrics.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = WindowsPath('C:/Users/User/AppData/Local/Temp/pytest-of-User/pytest-300/test_loader_malformed_json_fal0/malformed.json')
other = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/spec/v45')

    def relative_to(self, other, *, walk_up=False):
        """Return the relative path to another path identified by the passed
        arguments.  If the operation is not possible (because this is not
        related to the other path), raise ValueError.
    
        The *walk_up* parameter controls whether `..` may be used to resolve
        the path.
        """
        if not hasattr(other, 'with_segments'):
            other = self.with_segments(other)
        for step, path in enumerate(chain([other], other.parents)):
            if path == self or path in self.parents:
                break
            elif not walk_up:
>               raise ValueError(f"{str(self)!r} is not in the subpath of {str(other)!r}")
E               ValueError: 'C:\\Users\\User\\AppData\\Local\\Temp\\pytest-of-User\\pytest-300\\test_loader_malformed_json_fal0\\malformed.json' is not in the subpath of 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\v45'

..\..\..\..\AppData\Local\Programs\Python\Python314\Lib\pathlib\__init__.py:495: ValueError

During handling of the above exception, another exception occurred:

    def _load_floors_spec_unified() -> dict:
        """
        Load constitutional floors spec with strict priority order (Track B Authority v45.0).
    
        Priority (fail-closed, v42/v38/v35 support removed in v45.0):
        A) ARIFOS_FLOORS_SPEC (env path override) - highest priority (explicit operator authority)
        B) spec/v45/constitutional_floors.json (AUTHORITATIVE - v45.0 single source of truth)
        C) spec/v44/constitutional_floors.json (FALLBACK with deprecation warning)
        D) HARD FAIL (raise RuntimeError) - no legacy fallback
    
        Each candidate is validated for required keys before acceptance.
        On validation failure, falls through to next priority level.
    
        Returns:
            dict: The loaded spec with floor thresholds
    
        Raises:
            RuntimeError: If v45/v44 spec missing/invalid (v42/v38/v35 support removed)
        """
        # Navigate to repo root: metrics.py -> enforcement/ -> arifos_core/ -> repo root
        pkg_dir = Path(__file__).resolve().parent.parent.parent
        loaded_from = None
        spec_data = None
    
        # v45.0: Legacy fallback removed (ARIFOS_ALLOW_LEGACY_SPEC no longer supported)
        # Only v45\u2192v44\u2192FAIL is supported
        allow_legacy = False
    
        # Try v45 schema first, fallback to v44
        v45_schema_path = pkg_dir / "spec" / "v45" / "schema" / "constitutional_floors.schema.json"
        v44_schema_path = pkg_dir / "spec" / "v44" / "schema" / "constitutional_floors.schema.json"
        schema_path = v45_schema_path if v45_schema_path.exists() else v44_schema_path
    
        # Verify cryptographic manifest (tamper-evident integrity for v45/v44 specs)
        # Try v45 manifest first, fallback to v44
        v45_manifest_path = pkg_dir / "spec" / "v45" / "MANIFEST.sha256.json"
        v44_manifest_path = pkg_dir / "spec" / "v44" / "MANIFEST.sha256.json"
        manifest_path = v45_manifest_path if v45_manifest_path.exists() else v44_manifest_path
        verify_manifest(pkg_dir, manifest_path, allow_legacy=allow_legacy)
    
        # Priority A: Environment variable override (highest priority)
        env_path = os.getenv("ARIFOS_FLOORS_SPEC")
        if env_path:
            env_spec_path = Path(env_path).resolve()
    
            # Strict mode: env override must point to spec/v45/ or spec/v44/ (manifest-covered files only)
            if not allow_legacy:
                v45_dir = (pkg_dir / "spec" / "v45").resolve()
                v44_dir = (pkg_dir / "spec" / "v44").resolve()
                try:
                    # Check if env path is within spec/v45/ or spec/v44/
                    try:
                        env_spec_path.relative_to(v45_dir)
                    except ValueError:
>                       env_spec_path.relative_to(v44_dir)

arifos_core\enforcement\metrics.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = WindowsPath('C:/Users/User/AppData/Local/Temp/pytest-of-User/pytest-300/test_loader_malformed_json_fal0/malformed.json')
other = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/spec/v44')

    def relative_to(self, other, *, walk_up=False):
        """Return the relative path to another path identified by the passed
        arguments.  If the operation is not possible (because this is not
        related to the other path), raise ValueError.
    
        The *walk_up* parameter controls whether `..` may be used to resolve
        the path.
        """
        if not hasattr(other, 'with_segments'):
            other = self.with_segments(other)
        for step, path in enumerate(chain([other], other.parents)):
            if path == self or path in self.parents:
                break
            elif not walk_up:
>               raise ValueError(f"{str(self)!r} is not in the subpath of {str(other)!r}")
E               ValueError: 'C:\\Users\\User\\AppData\\Local\\Temp\\pytest-of-User\\pytest-300\\test_loader_malformed_json_fal0\\malformed.json' is not in the subpath of 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\v44'

..\..\..\..\AppData\Local\Programs\Python\Python314\Lib\pathlib\__init__.py:495: ValueError

During handling of the above exception, another exception occurred:

tmp_path = WindowsPath('C:/Users/User/AppData/Local/Temp/pytest-of-User/pytest-300/test_loader_malformed_json_fal0')

    def test_loader_malformed_json_falls_through(tmp_path):
        """Malformed JSON falls through to next priority."""
        # Create malformed JSON file
        malformed_path = tmp_path / "malformed.json"
        malformed_path.write_text("{this is not valid json")
    
        # Use legacy mode to allow external path (test is for fallthrough logic, not path restriction)
        with patch.dict(os.environ, {
            "ARIFOS_FLOORS_SPEC": str(malformed_path),
            "ARIFOS_ALLOW_LEGACY_SPEC": "1"
        }):
>           spec = _load_floors_spec_unified()
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_spec_loader_unified.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _load_floors_spec_unified() -> dict:
        """
        Load constitutional floors spec with strict priority order (Track B Authority v45.0).
    
        Priority (fail-closed, v42/v38/v35 support removed in v45.0):
        A) ARIFOS_FLOORS_SPEC (env path override) - highest priority (explicit operator authority)
        B) spec/v45/constitutional_floors.json (AUTHORITATIVE - v45.0 single source of truth)
        C) spec/v44/constitutional_floors.json (FALLBACK with deprecation warning)
        D) HARD FAIL (raise RuntimeError) - no legacy fallback
    
        Each candidate is validated for required keys before acceptance.
        On validation failure, falls through to next priority level.
    
        Returns:
            dict: The loaded spec with floor thresholds
    
        Raises:
            RuntimeError: If v45/v44 spec missing/invalid (v42/v38/v35 support removed)
        """
        # Navigate to repo root: metrics.py -> enforcement/ -> arifos_core/ -> repo root
        pkg_dir = Path(__file__).resolve().parent.parent.parent
        loaded_from = None
        spec_data = None
    
        # v45.0: Legacy fallback removed (ARIFOS_ALLOW_LEGACY_SPEC no longer supported)
        # Only v45\u2192v44\u2192FAIL is supported
        allow_legacy = False
    
        # Try v45 schema first, fallback to v44
        v45_schema_path = pkg_dir / "spec" / "v45" / "schema" / "constitutional_floors.schema.json"
        v44_schema_path = pkg_dir / "spec" / "v44" / "schema" / "constitutional_floors.schema.json"
        schema_path = v45_schema_path if v45_schema_path.exists() else v44_schema_path
    
        # Verify cryptographic manifest (tamper-evident integrity for v45/v44 specs)
        # Try v45 manifest first, fallback to v44
        v45_manifest_path = pkg_dir / "spec" / "v45" / "MANIFEST.sha256.json"
        v44_manifest_path = pkg_dir / "spec" / "v44" / "MANIFEST.sha256.json"
        manifest_path = v45_manifest_path if v45_manifest_path.exists() else v44_manifest_path
        verify_manifest(pkg_dir, manifest_path, allow_legacy=allow_legacy)
    
        # Priority A: Environment variable override (highest priority)
        env_path = os.getenv("ARIFOS_FLOORS_SPEC")
        if env_path:
            env_spec_path = Path(env_path).resolve()
    
            # Strict mode: env override must point to spec/v45/ or spec/v44/ (manifest-covered files only)
            if not allow_legacy:
                v45_dir = (pkg_dir / "spec" / "v45").resolve()
                v44_dir = (pkg_dir / "spec" / "v44").resolve()
                try:
                    # Check if env path is within spec/v45/ or spec/v44/
                    try:
                        env_spec_path.relative_to(v45_dir)
                    except ValueError:
                        env_spec_path.relative_to(v44_dir)
                except ValueError:
                    # Path is outside both spec/v45/ and spec/v44/ - reject in strict mode
>                   raise RuntimeError(
                        f"TRACK B AUTHORITY FAILURE: Environment override points to path outside spec/v45/ or spec/v44/.\n"
                        f"  Override path: {env_spec_path}\n"
                        f"  Expected within: {v45_dir} or {v44_dir}\n"
                        f"In strict mode, only manifest-covered files (spec/v45/ or spec/v44/) are allowed.\n"
                        f"Set ARIFOS_ALLOW_LEGACY_SPEC=1 to bypass (NOT RECOMMENDED)."
                    )
E                   RuntimeError: TRACK B AUTHORITY FAILURE: Environment override points to path outside spec/v45/ or spec/v44/.
E                     Override path: C:\Users\User\AppData\Local\Temp\pytest-of-User\pytest-300\test_loader_malformed_json_fal0\malformed.json
E                     Expected within: C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\v45 or C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\v44
E                   In strict mode, only manifest-covered files (spec/v45/ or spec/v44/) are allowed.
E                   Set ARIFOS_ALLOW_LEGACY_SPEC=1 to bypass (NOT RECOMMENDED).

arifos_core\enforcement\metrics.py:142: RuntimeError
___________________ test_loader_invalid_spec_falls_through ____________________

    def _load_floors_spec_unified() -> dict:
        """
        Load constitutional floors spec with strict priority order (Track B Authority v45.0).
    
        Priority (fail-closed, v42/v38/v35 support removed in v45.0):
        A) ARIFOS_FLOORS_SPEC (env path override) - highest priority (explicit operator authority)
        B) spec/v45/constitutional_floors.json (AUTHORITATIVE - v45.0 single source of truth)
        C) spec/v44/constitutional_floors.json (FALLBACK with deprecation warning)
        D) HARD FAIL (raise RuntimeError) - no legacy fallback
    
        Each candidate is validated for required keys before acceptance.
        On validation failure, falls through to next priority level.
    
        Returns:
            dict: The loaded spec with floor thresholds
    
        Raises:
            RuntimeError: If v45/v44 spec missing/invalid (v42/v38/v35 support removed)
        """
        # Navigate to repo root: metrics.py -> enforcement/ -> arifos_core/ -> repo root
        pkg_dir = Path(__file__).resolve().parent.parent.parent
        loaded_from = None
        spec_data = None
    
        # v45.0: Legacy fallback removed (ARIFOS_ALLOW_LEGACY_SPEC no longer supported)
        # Only v45\u2192v44\u2192FAIL is supported
        allow_legacy = False
    
        # Try v45 schema first, fallback to v44
        v45_schema_path = pkg_dir / "spec" / "v45" / "schema" / "constitutional_floors.schema.json"
        v44_schema_path = pkg_dir / "spec" / "v44" / "schema" / "constitutional_floors.schema.json"
        schema_path = v45_schema_path if v45_schema_path.exists() else v44_schema_path
    
        # Verify cryptographic manifest (tamper-evident integrity for v45/v44 specs)
        # Try v45 manifest first, fallback to v44
        v45_manifest_path = pkg_dir / "spec" / "v45" / "MANIFEST.sha256.json"
        v44_manifest_path = pkg_dir / "spec" / "v44" / "MANIFEST.sha256.json"
        manifest_path = v45_manifest_path if v45_manifest_path.exists() else v44_manifest_path
        verify_manifest(pkg_dir, manifest_path, allow_legacy=allow_legacy)
    
        # Priority A: Environment variable override (highest priority)
        env_path = os.getenv("ARIFOS_FLOORS_SPEC")
        if env_path:
            env_spec_path = Path(env_path).resolve()
    
            # Strict mode: env override must point to spec/v45/ or spec/v44/ (manifest-covered files only)
            if not allow_legacy:
                v45_dir = (pkg_dir / "spec" / "v45").resolve()
                v44_dir = (pkg_dir / "spec" / "v44").resolve()
                try:
                    # Check if env path is within spec/v45/ or spec/v44/
                    try:
>                       env_spec_path.relative_to(v45_dir)

arifos_core\enforcement\metrics.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = WindowsPath('C:/Users/User/AppData/Local/Temp/pytest-of-User/pytest-300/test_loader_invalid_spec_falls0/invalid_spec.json')
other = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/spec/v45')

    def relative_to(self, other, *, walk_up=False):
        """Return the relative path to another path identified by the passed
        arguments.  If the operation is not possible (because this is not
        related to the other path), raise ValueError.
    
        The *walk_up* parameter controls whether `..` may be used to resolve
        the path.
        """
        if not hasattr(other, 'with_segments'):
            other = self.with_segments(other)
        for step, path in enumerate(chain([other], other.parents)):
            if path == self or path in self.parents:
                break
            elif not walk_up:
>               raise ValueError(f"{str(self)!r} is not in the subpath of {str(other)!r}")
E               ValueError: 'C:\\Users\\User\\AppData\\Local\\Temp\\pytest-of-User\\pytest-300\\test_loader_invalid_spec_falls0\\invalid_spec.json' is not in the subpath of 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\v45'

..\..\..\..\AppData\Local\Programs\Python\Python314\Lib\pathlib\__init__.py:495: ValueError

During handling of the above exception, another exception occurred:

    def _load_floors_spec_unified() -> dict:
        """
        Load constitutional floors spec with strict priority order (Track B Authority v45.0).
    
        Priority (fail-closed, v42/v38/v35 support removed in v45.0):
        A) ARIFOS_FLOORS_SPEC (env path override) - highest priority (explicit operator authority)
        B) spec/v45/constitutional_floors.json (AUTHORITATIVE - v45.0 single source of truth)
        C) spec/v44/constitutional_floors.json (FALLBACK with deprecation warning)
        D) HARD FAIL (raise RuntimeError) - no legacy fallback
    
        Each candidate is validated for required keys before acceptance.
        On validation failure, falls through to next priority level.
    
        Returns:
            dict: The loaded spec with floor thresholds
    
        Raises:
            RuntimeError: If v45/v44 spec missing/invalid (v42/v38/v35 support removed)
        """
        # Navigate to repo root: metrics.py -> enforcement/ -> arifos_core/ -> repo root
        pkg_dir = Path(__file__).resolve().parent.parent.parent
        loaded_from = None
        spec_data = None
    
        # v45.0: Legacy fallback removed (ARIFOS_ALLOW_LEGACY_SPEC no longer supported)
        # Only v45\u2192v44\u2192FAIL is supported
        allow_legacy = False
    
        # Try v45 schema first, fallback to v44
        v45_schema_path = pkg_dir / "spec" / "v45" / "schema" / "constitutional_floors.schema.json"
        v44_schema_path = pkg_dir / "spec" / "v44" / "schema" / "constitutional_floors.schema.json"
        schema_path = v45_schema_path if v45_schema_path.exists() else v44_schema_path
    
        # Verify cryptographic manifest (tamper-evident integrity for v45/v44 specs)
        # Try v45 manifest first, fallback to v44
        v45_manifest_path = pkg_dir / "spec" / "v45" / "MANIFEST.sha256.json"
        v44_manifest_path = pkg_dir / "spec" / "v44" / "MANIFEST.sha256.json"
        manifest_path = v45_manifest_path if v45_manifest_path.exists() else v44_manifest_path
        verify_manifest(pkg_dir, manifest_path, allow_legacy=allow_legacy)
    
        # Priority A: Environment variable override (highest priority)
        env_path = os.getenv("ARIFOS_FLOORS_SPEC")
        if env_path:
            env_spec_path = Path(env_path).resolve()
    
            # Strict mode: env override must point to spec/v45/ or spec/v44/ (manifest-covered files only)
            if not allow_legacy:
                v45_dir = (pkg_dir / "spec" / "v45").resolve()
                v44_dir = (pkg_dir / "spec" / "v44").resolve()
                try:
                    # Check if env path is within spec/v45/ or spec/v44/
                    try:
                        env_spec_path.relative_to(v45_dir)
                    except ValueError:
>                       env_spec_path.relative_to(v44_dir)

arifos_core\enforcement\metrics.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = WindowsPath('C:/Users/User/AppData/Local/Temp/pytest-of-User/pytest-300/test_loader_invalid_spec_falls0/invalid_spec.json')
other = WindowsPath('C:/Users/User/OneDrive/Documents/GitHub/arifOS/spec/v44')

    def relative_to(self, other, *, walk_up=False):
        """Return the relative path to another path identified by the passed
        arguments.  If the operation is not possible (because this is not
        related to the other path), raise ValueError.
    
        The *walk_up* parameter controls whether `..` may be used to resolve
        the path.
        """
        if not hasattr(other, 'with_segments'):
            other = self.with_segments(other)
        for step, path in enumerate(chain([other], other.parents)):
            if path == self or path in self.parents:
                break
            elif not walk_up:
>               raise ValueError(f"{str(self)!r} is not in the subpath of {str(other)!r}")
E               ValueError: 'C:\\Users\\User\\AppData\\Local\\Temp\\pytest-of-User\\pytest-300\\test_loader_invalid_spec_falls0\\invalid_spec.json' is not in the subpath of 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\v44'

..\..\..\..\AppData\Local\Programs\Python\Python314\Lib\pathlib\__init__.py:495: ValueError

During handling of the above exception, another exception occurred:

tmp_path = WindowsPath('C:/Users/User/AppData/Local/Temp/pytest-of-User/pytest-300/test_loader_invalid_spec_falls0')

    def test_loader_invalid_spec_falls_through(tmp_path):
        """Valid JSON but invalid spec structure falls through to next priority (with legacy mode)."""
        # Create valid JSON but missing required keys
        invalid_spec = {
            "version": "invalid-test",
            # Missing 'floors' and 'vitality' keys
        }
    
        invalid_path = tmp_path / "invalid_spec.json"
        invalid_path.write_text(json.dumps(invalid_spec))
    
        with patch.dict(os.environ, {
            "ARIFOS_FLOORS_SPEC": str(invalid_path),
            "ARIFOS_ALLOW_LEGACY_SPEC": "1"  # Allow fallthrough on invalid spec
        }):
>           spec = _load_floors_spec_unified()
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\test_spec_loader_unified.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def _load_floors_spec_unified() -> dict:
        """
        Load constitutional floors spec with strict priority order (Track B Authority v45.0).
    
        Priority (fail-closed, v42/v38/v35 support removed in v45.0):
        A) ARIFOS_FLOORS_SPEC (env path override) - highest priority (explicit operator authority)
        B) spec/v45/constitutional_floors.json (AUTHORITATIVE - v45.0 single source of truth)
        C) spec/v44/constitutional_floors.json (FALLBACK with deprecation warning)
        D) HARD FAIL (raise RuntimeError) - no legacy fallback
    
        Each candidate is validated for required keys before acceptance.
        On validation failure, falls through to next priority level.
    
        Returns:
            dict: The loaded spec with floor thresholds
    
        Raises:
            RuntimeError: If v45/v44 spec missing/invalid (v42/v38/v35 support removed)
        """
        # Navigate to repo root: metrics.py -> enforcement/ -> arifos_core/ -> repo root
        pkg_dir = Path(__file__).resolve().parent.parent.parent
        loaded_from = None
        spec_data = None
    
        # v45.0: Legacy fallback removed (ARIFOS_ALLOW_LEGACY_SPEC no longer supported)
        # Only v45\u2192v44\u2192FAIL is supported
        allow_legacy = False
    
        # Try v45 schema first, fallback to v44
        v45_schema_path = pkg_dir / "spec" / "v45" / "schema" / "constitutional_floors.schema.json"
        v44_schema_path = pkg_dir / "spec" / "v44" / "schema" / "constitutional_floors.schema.json"
        schema_path = v45_schema_path if v45_schema_path.exists() else v44_schema_path
    
        # Verify cryptographic manifest (tamper-evident integrity for v45/v44 specs)
        # Try v45 manifest first, fallback to v44
        v45_manifest_path = pkg_dir / "spec" / "v45" / "MANIFEST.sha256.json"
        v44_manifest_path = pkg_dir / "spec" / "v44" / "MANIFEST.sha256.json"
        manifest_path = v45_manifest_path if v45_manifest_path.exists() else v44_manifest_path
        verify_manifest(pkg_dir, manifest_path, allow_legacy=allow_legacy)
    
        # Priority A: Environment variable override (highest priority)
        env_path = os.getenv("ARIFOS_FLOORS_SPEC")
        if env_path:
            env_spec_path = Path(env_path).resolve()
    
            # Strict mode: env override must point to spec/v45/ or spec/v44/ (manifest-covered files only)
            if not allow_legacy:
                v45_dir = (pkg_dir / "spec" / "v45").resolve()
                v44_dir = (pkg_dir / "spec" / "v44").resolve()
                try:
                    # Check if env path is within spec/v45/ or spec/v44/
                    try:
                        env_spec_path.relative_to(v45_dir)
                    except ValueError:
                        env_spec_path.relative_to(v44_dir)
                except ValueError:
                    # Path is outside both spec/v45/ and spec/v44/ - reject in strict mode
>                   raise RuntimeError(
                        f"TRACK B AUTHORITY FAILURE: Environment override points to path outside spec/v45/ or spec/v44/.\n"
                        f"  Override path: {env_spec_path}\n"
                        f"  Expected within: {v45_dir} or {v44_dir}\n"
                        f"In strict mode, only manifest-covered files (spec/v45/ or spec/v44/) are allowed.\n"
                        f"Set ARIFOS_ALLOW_LEGACY_SPEC=1 to bypass (NOT RECOMMENDED)."
                    )
E                   RuntimeError: TRACK B AUTHORITY FAILURE: Environment override points to path outside spec/v45/ or spec/v44/.
E                     Override path: C:\Users\User\AppData\Local\Temp\pytest-of-User\pytest-300\test_loader_invalid_spec_falls0\invalid_spec.json
E                     Expected within: C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\v45 or C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\v44
E                   In strict mode, only manifest-covered files (spec/v45/ or spec/v44/) are allowed.
E                   Set ARIFOS_ALLOW_LEGACY_SPEC=1 to bypass (NOT RECOMMENDED).

arifos_core\enforcement\metrics.py:142: RuntimeError
______________________ test_loaded_from_marker_accurate _______________________

    def test_loaded_from_marker_accurate():
        """_loaded_from marker accurately reflects source."""
        # With no env var, should load v44 (v44.0 Track B authority)
        with patch.dict(os.environ, {}, clear=False):
            os.environ.pop("ARIFOS_FLOORS_SPEC", None)
    
            spec = _load_floors_spec_unified()
            loaded_from = spec["_loaded_from"]
    
            # Should be v44 (authoritative source as of v44.0)
            valid_sources = [
                "spec/v44/constitutional_floors.json",
                "spec\\v44\\constitutional_floors.json",  # Windows path
            ]
    
>           assert any(source in loaded_from for source in valid_sources), \
                f"Expected v44 path, got: {loaded_from}"
E           AssertionError: Expected v44 path, got: spec/v45/constitutional_floors.json
E           assert False
E            +  where False = any(<generator object test_loaded_from_marker_accurate.<locals>.<genexpr> at 0x000002704207EB20>)

tests\test_spec_loader_unified.py:324: AssertionError
_ TestConstitutionalFloorsManifestEnforcement.test_default_import_verifies_manifest_successfully _

self = <tests.test_spec_v44_manifest_enforcement_subprocess.TestConstitutionalFloorsManifestEnforcement object at 0x000002703F98A490>

        def test_default_import_verifies_manifest_successfully(self):
            """PROOF: Default import with unmodified v44 specs passes manifest verification."""
            code = """
    from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
    print('MANIFEST_VERIFIED:SUCCESS')
    """
            result = subprocess.run(
                [sys.executable, "-c", code],
                capture_output=True,
                text=True,
                timeout=10,
                env={**os.environ, 'ARIFOS_ALLOW_LEGACY_SPEC': '0'}  # Strict mode
            )
    
>           assert result.returncode == 0, f"Process should succeed with valid manifest, got stderr: {result.stderr}"
E           AssertionError: Process should succeed with valid manifest, got stderr: Traceback (most recent call last):
E               File "<string>", line 2, in <module>
E                 from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
E             ImportError: cannot import name '_FLOORS_SPEC_V38' from 'arifos_core.enforcement.metrics' (C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\metrics.py)
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', '-c', "\nfrom arifo....enforcement.metrics\' (C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\arifos_core\\enforcement\\metrics.py)\n').returncode

tests\test_spec_v44_manifest_enforcement_subprocess.py:46: AssertionError
_ TestConstitutionalFloorsManifestEnforcement.test_missing_manifest_triggers_hard_fail _

self = <tests.test_spec_v44_manifest_enforcement_subprocess.TestConstitutionalFloorsManifestEnforcement object at 0x000002703F9D0770>

        def test_missing_manifest_triggers_hard_fail(self):
            """PROOF: Missing manifest file triggers RuntimeError in strict mode."""
            # Temporarily rename manifest to simulate missing
            manifest_path = Path("spec/v44/MANIFEST.sha256.json")
            backup_path = Path("spec/v44/MANIFEST.sha256.json.bak")
    
            # Skip if already backed up (test cleanup issue)
            if backup_path.exists():
                pytest.skip("Manifest backup already exists, cleanup needed")
    
            try:
                # Rename manifest
                shutil.move(str(manifest_path), str(backup_path))
    
                code = """
    from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
    print('SHOULD NOT REACH HERE')
    """
                result = subprocess.run(
                    [sys.executable, "-c", code],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    env={**os.environ, 'ARIFOS_ALLOW_LEGACY_SPEC': '0'}
                )
    
                # Should fail
                assert result.returncode != 0, \
                    f"Should have failed with missing manifest, got stdout: {result.stdout}"
    
                # Should contain manifest error
                stderr_lower = result.stderr.lower()
>               assert any(phrase in stderr_lower for phrase in [
                    "manifest not found",
                    "track b authority failure",
                    "cryptographic manifest"
                ]), f"Expected manifest error, got stderr: {result.stderr}"
E               AssertionError: Expected manifest error, got stderr: Traceback (most recent call last):
E                   File "<string>", line 2, in <module>
E                     from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
E                 ImportError: cannot import name '_FLOORS_SPEC_V38' from 'arifos_core.enforcement.metrics' (C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\metrics.py)
E                 
E               assert False
E                +  where False = any(<generator object TestConstitutionalFloorsManifestEnforcement.test_missing_manifest_triggers_hard_fail.<locals>.<genexpr> at 0x000002704207EA40>)

tests\test_spec_v44_manifest_enforcement_subprocess.py:118: AssertionError
_ TestConstitutionalFloorsManifestEnforcement.test_legacy_mode_bypasses_manifest_verification _

self = <tests.test_spec_v44_manifest_enforcement_subprocess.TestConstitutionalFloorsManifestEnforcement object at 0x000002703F9D08A0>

        def test_legacy_mode_bypasses_manifest_verification(self):
            """PROOF: ARIFOS_ALLOW_LEGACY_SPEC=1 bypasses manifest verification."""
            # Temporarily rename manifest
            manifest_path = Path("spec/v44/MANIFEST.sha256.json")
            backup_path = Path("spec/v44/MANIFEST.sha256.json.bak2")
    
            # Skip if already backed up
            if backup_path.exists():
                pytest.skip("Manifest backup already exists, cleanup needed")
    
            try:
                # Rename manifest
                shutil.move(str(manifest_path), str(backup_path))
    
                code = """
    from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
    print('LEGACY_MODE:SUCCESS')
    """
                result = subprocess.run(
                    [sys.executable, "-c", code],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    env={**os.environ, 'ARIFOS_ALLOW_LEGACY_SPEC': '1'}  # Legacy mode
                )
    
                # Should succeed (legacy mode bypasses verification)
>               assert result.returncode == 0, \
                    f"Should succeed in legacy mode, got stderr: {result.stderr}"
E                   AssertionError: Should succeed in legacy mode, got stderr: Traceback (most recent call last):
E                       File "<string>", line 2, in <module>
E                         from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
E                     ImportError: cannot import name '_FLOORS_SPEC_V38' from 'arifos_core.enforcement.metrics' (C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\metrics.py)
E                     
E                   assert 1 == 0
E                    +  where 1 = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', '-c', "\nfrom arifo....enforcement.metrics\' (C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\arifos_core\\enforcement\\metrics.py)\n').returncode

tests\test_spec_v44_manifest_enforcement_subprocess.py:156: AssertionError
___ TestGeniusLawManifestEnforcement.test_default_import_verifies_manifest ____

self = <tests.test_spec_v44_manifest_enforcement_subprocess.TestGeniusLawManifestEnforcement object at 0x000002703F98A710>

        def test_default_import_verifies_manifest(self):
            """PROOF: Default GENIUS LAW import passes manifest verification."""
            code = """
    from arifos_core.enforcement.genius_metrics import _GENIUS_SPEC_V38
    print('GENIUS_MANIFEST:SUCCESS')
    """
            result = subprocess.run(
                [sys.executable, "-c", code],
                capture_output=True,
                text=True,
                timeout=10,
                env={**os.environ, 'ARIFOS_ALLOW_LEGACY_SPEC': '0'}
            )
    
>           assert result.returncode == 0, f"Process should succeed, got stderr: {result.stderr}"
E           AssertionError: Process should succeed, got stderr: Traceback (most recent call last):
E               File "<string>", line 2, in <module>
E                 from arifos_core.enforcement.genius_metrics import _GENIUS_SPEC_V38
E             ImportError: cannot import name '_GENIUS_SPEC_V38' from 'arifos_core.enforcement.genius_metrics' (C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\genius_metrics.py)
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', '-c', "\nfrom arifo...enius_metrics\' (C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\arifos_core\\enforcement\\genius_metrics.py)\n').returncode

tests\test_spec_v44_manifest_enforcement_subprocess.py:184: AssertionError
_ TestConstitutionalFloorsSchemaEnforcement.test_valid_v44_spec_attaches_schema_used_marker _

self = <tests.test_spec_v44_schema_enforcement_subprocess.TestConstitutionalFloorsSchemaEnforcement object at 0x000002703F9D09D0>

        def test_valid_v44_spec_attaches_schema_used_marker(self):
            """PROOF: Valid v44 spec loads successfully and attaches _schema_used marker."""
            code = """
    from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
    if '_schema_used' in _FLOORS_SPEC_V38:
        print(f"SCHEMA_USED:{_FLOORS_SPEC_V38['_schema_used']}")
    else:
        print("SCHEMA_USED:NONE")
    """
            result = subprocess.run(
                [sys.executable, "-c", code],
                capture_output=True,
                text=True,
                timeout=10,
                env={**os.environ, 'ARIFOS_ALLOW_LEGACY_SPEC': '0'}  # Strict mode
            )
    
>           assert result.returncode == 0, f"Process failed: {result.stderr}"
E           AssertionError: Process failed: Traceback (most recent call last):
E               File "<string>", line 2, in <module>
E                 from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
E             ImportError: cannot import name '_FLOORS_SPEC_V38' from 'arifos_core.enforcement.metrics' (C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\metrics.py)
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', '-c', '\nfrom arifo....enforcement.metrics\' (C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\arifos_core\\enforcement\\metrics.py)\n').returncode

tests\test_spec_v44_schema_enforcement_subprocess.py:142: AssertionError
_ TestGeniusLawSchemaEnforcement.test_valid_genius_spec_attaches_schema_used_marker _

self = <tests.test_spec_v44_schema_enforcement_subprocess.TestGeniusLawSchemaEnforcement object at 0x000002703F98AFD0>

        def test_valid_genius_spec_attaches_schema_used_marker(self):
            """PROOF: Valid GENIUS spec loads successfully and attaches _schema_used marker."""
            code = """
    from arifos_core.enforcement.genius_metrics import _GENIUS_SPEC_V38
    if '_schema_used' in _GENIUS_SPEC_V38:
        print(f"SCHEMA_USED:{_GENIUS_SPEC_V38['_schema_used']}")
    else:
        print("SCHEMA_USED:NONE")
    """
            result = subprocess.run(
                [sys.executable, "-c", code],
                capture_output=True,
                text=True,
                timeout=10,
                env={**os.environ, 'ARIFOS_ALLOW_LEGACY_SPEC': '0'}  # Strict mode
            )
    
>           assert result.returncode == 0, f"Process failed: {result.stderr}"
E           AssertionError: Process failed: Traceback (most recent call last):
E               File "<string>", line 2, in <module>
E                 from arifos_core.enforcement.genius_metrics import _GENIUS_SPEC_V38
E             ImportError: cannot import name '_GENIUS_SPEC_V38' from 'arifos_core.enforcement.genius_metrics' (C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\genius_metrics.py)
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', '-c', '\nfrom arifo...enius_metrics\' (C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\arifos_core\\enforcement\\genius_metrics.py)\n').returncode

tests\test_spec_v44_schema_enforcement_subprocess.py:217: AssertionError
_ TestConstitutionalFloorsSubprocess.test_default_load_uses_v44_fresh_process _

self = <tests.test_spec_v44_subprocess_proof.TestConstitutionalFloorsSubprocess object at 0x000002703F98B390>

        def test_default_load_uses_v44_fresh_process(self):
            """PROOF: Fresh Python process loads spec/v44/constitutional_floors.json by default."""
            # Run in subprocess to bypass module caching
            code = """
    import sys
    from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
    print(f"VERSION:{_FLOORS_SPEC_V38['version']}")
    print(f"LOADED_FROM:{_FLOORS_SPEC_V38.get('_loaded_from', 'UNKNOWN')}")
    """
            result = subprocess.run(
                [sys.executable, "-c", code],
                capture_output=True,
                text=True,
                timeout=10
            )
    
>           assert result.returncode == 0, f"Process failed: {result.stderr}"
E           AssertionError: Process failed: Traceback (most recent call last):
E               File "<string>", line 3, in <module>
E                 from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
E             ImportError: cannot import name '_FLOORS_SPEC_V38' from 'arifos_core.enforcement.metrics' (C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\metrics.py)
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', '-c', '\nimport sys....enforcement.metrics\' (C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\arifos_core\\enforcement\\metrics.py)\n').returncode

tests\test_spec_v44_subprocess_proof.py:42: AssertionError
_ TestConstitutionalFloorsSubprocess.test_missing_v44_hard_fails_fresh_process _

self = <tests.test_spec_v44_subprocess_proof.TestConstitutionalFloorsSubprocess object at 0x000002703F98B4D0>

        def test_missing_v44_hard_fails_fresh_process(self):
            """PROOF: Missing spec/v44/ causes RuntimeError in fresh process."""
            # Temporarily rename v44 directory to simulate missing spec
            v44_path = Path(__file__).parent.parent / "spec" / "v44"
            v44_backup = Path(__file__).parent.parent / "spec" / "v44_backup_test"
    
            # Check if v44 exists
            if not v44_path.exists():
                pytest.skip("spec/v44 directory doesn't exist")
    
            try:
                # Rename v44 to simulate missing
                v44_path.rename(v44_backup)
    
                # Run loader in subprocess
                code = """
    import os
    os.environ['ARIFOS_ALLOW_LEGACY_SPEC'] = '0'  # Ensure fail-closed
    from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
    print('LOADED')  # Should NOT reach here
    """
                result = subprocess.run(
                    [sys.executable, "-c", code],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    env={**os.environ, 'ARIFOS_ALLOW_LEGACY_SPEC': '0'}
                )
    
                # Should fail (non-zero exit)
                assert result.returncode != 0, "Should have failed with missing v44"
                # Should contain hard-fail error message
>               assert "TRACK B AUTHORITY FAILURE" in result.stderr, \
                    f"Expected hard-fail error, got: {result.stderr}"
E                   AssertionError: Expected hard-fail error, got: Traceback (most recent call last):
E                       File "<string>", line 4, in <module>
E                         from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
E                     ImportError: cannot import name '_FLOORS_SPEC_V38' from 'arifos_core.enforcement.metrics' (C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\metrics.py)
E                     
E                   assert 'TRACK B AUTHORITY FAILURE' in 'Traceback (most recent call last):\n  File "<string>", line 4, in <module>\n    from arifos_core.enforcement.metrics ...e.enforcement.metrics\' (C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\arifos_core\\enforcement\\metrics.py)\n'
E                    +  where 'Traceback (most recent call last):\n  File "<string>", line 4, in <module>\n    from arifos_core.enforcement.metrics ...e.enforcement.metrics\' (C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\arifos_core\\enforcement\\metrics.py)\n' = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', '-c', "\nimport os\....enforcement.metrics\' (C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\arifos_core\\enforcement\\metrics.py)\n').stderr

tests\test_spec_v44_subprocess_proof.py:84: AssertionError
_ TestConstitutionalFloorsSubprocess.test_env_override_loads_custom_spec_fresh_process _

self = <tests.test_spec_v44_subprocess_proof.TestConstitutionalFloorsSubprocess object at 0x000002703F9D0B00>

        def test_env_override_loads_custom_spec_fresh_process(self):
            """PROOF: ARIFOS_FLOORS_SPEC env var loads custom spec in fresh process."""
            # Create custom spec file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                custom_spec = {
                    "version": "custom-subprocess-test",
                    "floors": {
                        "truth": {"threshold": 0.95, "operator": ">=", "type": "hard", "failure_action": "VOID"},
                        "delta_s": {"threshold": 0.0, "operator": ">=", "type": "hard", "failure_action": "VOID"},
                        "peace_squared": {"threshold": 1.0, "operator": ">=", "type": "soft", "failure_action": "PARTIAL"},
                        "kappa_r": {"threshold": 0.95, "operator": ">=", "type": "soft", "failure_action": "PARTIAL"},
                        "omega_0": {"threshold_min": 0.03, "threshold_max": 0.05, "operator": "in_range", "type": "hard", "failure_action": "VOID"},
                        "amanah": {"threshold": True, "operator": "==", "type": "hard", "failure_action": "VOID"},
                        "rasa": {"threshold": True, "operator": "==", "type": "hard", "failure_action": "VOID"},
                        "tri_witness": {"threshold": 0.95, "operator": ">=", "type": "soft", "failure_action": "PARTIAL"},
                        "anti_hantu": {"threshold": True, "operator": "==", "type": "meta", "failure_action": "VOID"}
                    },
                    "floor_categories": {"hard": {"floors": ["truth"], "failure_verdict": "VOID"}},
                    "precedence_order": {"order": []},
                    "verdicts": {},
                    "vitality": {"threshold": 1.0}
                }
                json.dump(custom_spec, f)
                custom_path = f.name
    
            try:
                # Run with env override
                code = f"""
    import sys
    from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
    print(f"VERSION:{{_FLOORS_SPEC_V38['version']}}")
    """
                result = subprocess.run(
                    [sys.executable, "-c", code],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    env={**os.environ, 'ARIFOS_FLOORS_SPEC': custom_path, 'ARIFOS_ALLOW_LEGACY_SPEC': '1'}
                )
    
>               assert result.returncode == 0, f"Process failed: {result.stderr}"
E               AssertionError: Process failed: Traceback (most recent call last):
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\metrics.py", line 137, in _load_floors_spec_unified
E                     env_spec_path.relative_to(v45_dir)
E                     ~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^
E                   File "C:\Users\User\AppData\Local\Programs\Python\Python314\Lib\pathlib\__init__.py", line 495, in relative_to
E                     raise ValueError(f"{str(self)!r} is not in the subpath of {str(other)!r}")
E                 ValueError: 'C:\\Users\\User\\AppData\\Local\\Temp\\tmpjpw4kflm.json' is not in the subpath of 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\v45'
E                 
E                 During handling of the above exception, another exception occurred:
E                 
E                 Traceback (most recent call last):
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\metrics.py", line 139, in _load_floors_spec_unified
E                     env_spec_path.relative_to(v44_dir)
E                     ~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^
E                   File "C:\Users\User\AppData\Local\Programs\Python\Python314\Lib\pathlib\__init__.py", line 495, in relative_to
E                     raise ValueError(f"{str(self)!r} is not in the subpath of {str(other)!r}")
E                 ValueError: 'C:\\Users\\User\\AppData\\Local\\Temp\\tmpjpw4kflm.json' is not in the subpath of 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\v44'
E                 
E                 During handling of the above exception, another exception occurred:
E                 
E                 Traceback (most recent call last):
E                   File "<string>", line 3, in <module>
E                     from arifos_core.enforcement.metrics import _FLOORS_SPEC_V38
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\__init__.py", line 40, in <module>
E                     from .enforcement.metrics import Metrics, FloorsVerdict, ConstitutionalMetrics
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\__init__.py", line 11, in <module>
E                     from .metrics import Metrics, FloorsVerdict, ConstitutionalMetrics
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\metrics.py", line 226, in <module>
E                     _FLOORS_SPEC = _load_floors_spec_unified()
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\metrics.py", line 142, in _load_floors_spec_unified
E                     raise RuntimeError(
E                     ...<5 lines>...
E                     )
E                 RuntimeError: TRACK B AUTHORITY FAILURE: Environment override points to path outside spec/v45/ or spec/v44/.
E                   Override path: C:\Users\User\AppData\Local\Temp\tmpjpw4kflm.json
E                   Expected within: C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\v45 or C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\v44
E                 In strict mode, only manifest-covered files (spec/v45/ or spec/v44/) are allowed.
E                 Set ARIFOS_ALLOW_LEGACY_SPEC=1 to bypass (NOT RECOMMENDED).
E                 
E               assert 1 == 0
E                +  where 1 = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', '-c', '\nimport sys...st-covered files (spec/v45/ or spec/v44/) are allowed.\nSet ARIFOS_ALLOW_LEGACY_SPEC=1 to bypass (NOT RECOMMENDED).\n').returncode

tests\test_spec_v44_subprocess_proof.py:132: AssertionError
____ TestGeniusMetricsSubprocess.test_default_load_uses_v44_fresh_process _____

self = <tests.test_spec_v44_subprocess_proof.TestGeniusMetricsSubprocess object at 0x000002703F98B610>

        def test_default_load_uses_v44_fresh_process(self):
            """PROOF: Fresh Python process loads spec/v44/genius_law.json by default."""
            code = """
    from arifos_core.enforcement.genius_metrics import _GENIUS_SPEC_V38
    print(f"VERSION:{_GENIUS_SPEC_V38['version']}")
    """
            result = subprocess.run(
                [sys.executable, "-c", code],
                capture_output=True,
                text=True,
                timeout=10
            )
    
>           assert result.returncode == 0, f"Process failed: {result.stderr}"
E           AssertionError: Process failed: Traceback (most recent call last):
E               File "<string>", line 2, in <module>
E                 from arifos_core.enforcement.genius_metrics import _GENIUS_SPEC_V38
E             ImportError: cannot import name '_GENIUS_SPEC_V38' from 'arifos_core.enforcement.genius_metrics' (C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\genius_metrics.py)
E             
E           assert 1 == 0
E            +  where 1 = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', '-c', '\nfrom arifo...enius_metrics\' (C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\arifos_core\\enforcement\\genius_metrics.py)\n').returncode

tests\test_spec_v44_subprocess_proof.py:156: AssertionError
______ TestGeniusMetricsSubprocess.test_env_override_works_fresh_process ______

self = <tests.test_spec_v44_subprocess_proof.TestGeniusMetricsSubprocess object at 0x000002703F98B750>

        def test_env_override_works_fresh_process(self):
            """PROOF: ARIFOS_GENIUS_SPEC env var loads custom spec in fresh process."""
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                custom_spec = {
                    "version": "custom-genius-subprocess",
                    "verdict_logic": {
                        "constants": {
                            "G_SEAL": 0.80,
                            "G_VOID": 0.50,
                            "PSI_SEAL": 1.00,
                            "PSI_SABAR": 0.95,
                            "CDARK_SEAL": 0.30,
                            "CDARK_WARN": 0.60
                        }
                    }
                }
                json.dump(custom_spec, f)
                custom_path = f.name
    
            try:
                code = """
    from arifos_core.enforcement.genius_metrics import _GENIUS_SPEC_V38
    print(f"VERSION:{_GENIUS_SPEC_V38['version']}")
    """
                result = subprocess.run(
                    [sys.executable, "-c", code],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    env={**os.environ, 'ARIFOS_GENIUS_SPEC': custom_path, 'ARIFOS_ALLOW_LEGACY_SPEC': '1'}
                )
    
>               assert result.returncode == 0, f"Process failed: {result.stderr}"
E               AssertionError: Process failed: Traceback (most recent call last):
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\genius_metrics.py", line 100, in _load_genius_spec
E                     env_spec_path.relative_to(v45_dir)
E                     ~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^
E                   File "C:\Users\User\AppData\Local\Programs\Python\Python314\Lib\pathlib\__init__.py", line 495, in relative_to
E                     raise ValueError(f"{str(self)!r} is not in the subpath of {str(other)!r}")
E                 ValueError: 'C:\\Users\\User\\AppData\\Local\\Temp\\tmp2ml9mb69.json' is not in the subpath of 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\v45'
E                 
E                 During handling of the above exception, another exception occurred:
E                 
E                 Traceback (most recent call last):
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\genius_metrics.py", line 102, in _load_genius_spec
E                     env_spec_path.relative_to(v44_dir)
E                     ~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^
E                   File "C:\Users\User\AppData\Local\Programs\Python\Python314\Lib\pathlib\__init__.py", line 495, in relative_to
E                     raise ValueError(f"{str(self)!r} is not in the subpath of {str(other)!r}")
E                 ValueError: 'C:\\Users\\User\\AppData\\Local\\Temp\\tmp2ml9mb69.json' is not in the subpath of 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\v44'
E                 
E                 During handling of the above exception, another exception occurred:
E                 
E                 Traceback (most recent call last):
E                   File "<string>", line 2, in <module>
E                     from arifos_core.enforcement.genius_metrics import _GENIUS_SPEC_V38
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\__init__.py", line 40, in <module>
E                     from .enforcement.metrics import Metrics, FloorsVerdict, ConstitutionalMetrics
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\__init__.py", line 12, in <module>
E                     from .genius_metrics import (
E                     ...<5 lines>...
E                     )
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\genius_metrics.py", line 170, in <module>
E                     _GENIUS_SPEC = _load_genius_spec()
E                   File "C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\enforcement\genius_metrics.py", line 105, in _load_genius_spec
E                     raise RuntimeError(
E                     ...<5 lines>...
E                     )
E                 RuntimeError: TRACK B AUTHORITY FAILURE: Environment override points to path outside spec/v45/ or spec/v44/.
E                   Override path: C:\Users\User\AppData\Local\Temp\tmp2ml9mb69.json
E                   Expected within: C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\v45 or C:\Users\User\OneDrive\Documents\GitHub\arifOS\spec\v44
E                 In strict mode, only manifest-covered files are allowed.
E                 Set ARIFOS_ALLOW_LEGACY_SPEC=1 to bypass (NOT RECOMMENDED).
E                 
E               assert 1 == 0
E                +  where 1 = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', '-c', '\nfrom arifo... strict mode, only manifest-covered files are allowed.\nSet ARIFOS_ALLOW_LEGACY_SPEC=1 to bypass (NOT RECOMMENDED).\n').returncode

tests\test_spec_v44_subprocess_proof.py:191: AssertionError
____ TestSessionPhysicsSubprocess.test_default_load_uses_v44_fresh_process ____

self = <tests.test_spec_v44_subprocess_proof.TestSessionPhysicsSubprocess object at 0x000002703F98B890>

        def test_default_load_uses_v44_fresh_process(self):
            """PROOF: Fresh Python process loads spec/v44/session_physics.json by default."""
            code = """
    from arifos_core.governance.session_physics import _PHYSICS_SPEC
    print(f"VERSION:{_PHYSICS_SPEC['version']}")
    """
            result = subprocess.run(
                [sys.executable, "-c", code],
                capture_output=True,
                text=True,
                timeout=10
            )
    
            assert result.returncode == 0, f"Process failed: {result.stderr}"
>           assert "VERSION:v44.0" in result.stdout, f"Expected v44.0, got: {result.stdout}"
E           AssertionError: Expected v44.0, got: VERSION:v45.0
E             
E           assert 'VERSION:v44.0' in 'VERSION:v45.0\n'
E            +  where 'VERSION:v45.0\n' = CompletedProcess(args=['C:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python314\\python.exe', '-c', '\nfrom arifo...t _PHYSICS_SPEC\nprint(f"VERSION:{_PHYSICS_SPEC[\'version\']}")\n'], returncode=0, stdout='VERSION:v45.0\n', stderr='').stdout

tests\test_spec_v44_subprocess_proof.py:216: AssertionError
____________ TestConstitutionalInvariants.test_floor_ids_semantic _____________

self = <tests.test_v39_ci_guardrails.TestConstitutionalInvariants object at 0x000002703F9F9450>

    def test_floor_ids_semantic(self):
        """F# numbering must be semantic (F1=Truth through F9=AntiHantu)"""
        spec_path = REPO_ROOT / "spec" / "constitutional_floors_v38Omega.json"
>       with open(spec_path) as f:
             ^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\constitutional_floors_v38Omega.json'

tests\test_v39_ci_guardrails.py:24: FileNotFoundError
____________ TestConstitutionalInvariants.test_precedence_explicit ____________

self = <tests.test_v39_ci_guardrails.TestConstitutionalInvariants object at 0x000002703F9F9590>

    def test_precedence_explicit(self):
        """P# precedence must be defined for all 9 floors"""
        spec_path = REPO_ROOT / "spec" / "constitutional_floors_v38Omega.json"
>       with open(spec_path) as f:
             ^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\constitutional_floors_v38Omega.json'

tests\test_v39_ci_guardrails.py:48: FileNotFoundError
_____________ TestConstitutionalInvariants.test_rasa_r1_enforced ______________

self = <tests.test_v39_ci_guardrails.TestConstitutionalInvariants object at 0x000002703F9D1F30>

    def test_rasa_r1_enforced(self):
        """RASA R1 must have fail-closed enforcement"""
        spec_path = REPO_ROOT / "spec" / "constitutional_floors_v38Omega.json"
>       with open(spec_path) as f:
             ^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\constitutional_floors_v38Omega.json'

tests\test_v39_ci_guardrails.py:69: FileNotFoundError
__________ TestConstitutionalInvariants.test_psi_canonical_preserved __________

self = <tests.test_v39_ci_guardrails.TestConstitutionalInvariants object at 0x000002703F9D2060>

    def test_psi_canonical_preserved(self):
        """Psi formula must preserve canonical definition"""
        # Psi is in genius_law spec, check it documents the canonical formula
        genius_path = REPO_ROOT / "spec" / "genius_law_v38Omega.json"
        if genius_path.exists():
            with open(genius_path) as f:
                genius = json.load(f)
            if "psi" in genius.get("metrics", {}):
                psi = genius["metrics"]["psi"]
                assert "formula" in psi, "Psi missing formula"
        # Alternative: check constitutional_floors has vitality reference
        spec_path = REPO_ROOT / "spec" / "constitutional_floors_v38Omega.json"
>       with open(spec_path) as f:
             ^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\constitutional_floors_v38Omega.json'

tests\test_v39_ci_guardrails.py:94: FileNotFoundError
____________ TestSpecVersionAlignment.test_spec_version_is_v38_3_0 ____________

self = <tests.test_v39_ci_guardrails.TestSpecVersionAlignment object at 0x000002703F9F96D0>

    def test_spec_version_is_v38_3_0(self):
        spec_path = REPO_ROOT / "spec" / "constitutional_floors_v38Omega.json"
>       with open(spec_path) as f:
             ^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\constitutional_floors_v38Omega.json'

tests\test_v39_ci_guardrails.py:125: FileNotFoundError
_______ TestFloorCoverageCompleteness.test_all_floors_have_stage_hooks ________

self = <tests.test_v39_ci_guardrails.TestFloorCoverageCompleteness object at 0x000002703F9F9810>

    def test_all_floors_have_stage_hooks(self):
        spec_path = REPO_ROOT / "spec" / "constitutional_floors_v38Omega.json"
>       with open(spec_path) as f:
             ^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\constitutional_floors_v38Omega.json'

tests\test_v39_ci_guardrails.py:138: FileNotFoundError
________ TestFloorCoverageCompleteness.test_all_floors_have_thresholds ________

self = <tests.test_v39_ci_guardrails.TestFloorCoverageCompleteness object at 0x000002703F9F9950>

    def test_all_floors_have_thresholds(self):
        spec_path = REPO_ROOT / "spec" / "constitutional_floors_v38Omega.json"
>       with open(spec_path) as f:
             ^^^^^^^^^^^^^^^
E       FileNotFoundError: [Errno 2] No such file or directory: 'C:\\Users\\User\\OneDrive\\Documents\\GitHub\\arifOS\\spec\\constitutional_floors_v38Omega.json'

tests\test_v39_ci_guardrails.py:153: FileNotFoundError
______ TestPatchA_LaneScopedPsi.test_soft_degrades_to_partial_on_low_psi ______

self = <tests.test_v45_patch_b1_fixes.TestPatchA_LaneScopedPsi object at 0x000002703F9FA0D0>

    def test_soft_degrades_to_partial_on_low_psi(self):
        """SOFT queries should degrade to PARTIAL when \u03a8 < 1.0."""
        metrics = Metrics(
            truth=0.87,
            delta_s=0.15,
            peace_squared=1.02,
            kappa_r=0.96,
            omega_0=0.04,
            amanah=True,
            tri_witness=0.97,
            psi=0.92,  # \u03a8 < 1.0
        )
    
        verdict = apex_review(
            metrics=metrics,
            lane="SOFT",
            prompt="explain machine learning",
            response_text="Machine learning uses algorithms...",
        )
    
        # SOFT with low \u03a8 should degrade to PARTIAL (not VOID)
>       assert verdict.verdict == Verdict.PARTIAL, f"Expected PARTIAL, got {verdict.verdict}"
E       AssertionError: Expected PARTIAL, got SEAL
E       assert <Verdict.SEAL: 'SEAL'> == <Verdict.PARTIAL: 'PARTIAL'>
E        +  where <Verdict.SEAL: 'SEAL'> = ApexVerdict(verdict=<Verdict.SEAL: 'SEAL'>, pulse=87.0, reason='All floors pass. G=0.94, C_dark=0.00. Approved.', floo...lt_ok=True, behavior_ok=True, ontology_ok=True, sleeper_ok=True), genius_index=0.9393939393939394, dark_cleverness=0.0).verdict
E        +  and   <Verdict.PARTIAL: 'PARTIAL'> = Verdict.PARTIAL

tests\test_v45_patch_b1_fixes.py:68: AssertionError
============================== warnings summary ===============================
arifos_core\evidence\evidence_pack.py:52
  C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\evidence\evidence_pack.py:52: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    @validator("query_hash")

arifos_core\evidence\evidence_pack.py:58
  C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\evidence\evidence_pack.py:58: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    @validator("hash_chain_provenance", each_item=True)

arifos_core\evidence\evidence_pack.py:64
  C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\evidence\evidence_pack.py:64: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    @validator("source_uris")

..\..\..\..\AppData\Local\Programs\Python\Python314\Lib\site-packages\litellm\litellm_core_utils\logging_utils.py:273: 17 warnings
  C:\Users\User\AppData\Local\Programs\Python\Python314\Lib\site-packages\litellm\litellm_core_utils\logging_utils.py:273: DeprecationWarning: 'asyncio.iscoroutinefunction' is deprecated and slated for removal in Python 3.16; use inspect.iscoroutinefunction() instead
    if asyncio.iscoroutinefunction(func):

tests/governance/test_proof_of_governance.py::test_no_semantic_leak_into_receipt
  C:\Users\User\OneDrive\Documents\GitHub\arifOS\tests\governance\test_proof_of_governance.py:152: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    data = json.dumps(receipt.dict()) # Pydantic dict

tests/test_fag.py::TestFAGLedgerIntegration::test_ledger_enabled_by_default
tests/test_mcp_fag_integration.py::TestMCPFAGTool::test_ledger_integration_via_mcp
  C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\governance\ledger.py:26: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    "timestamp": datetime.datetime.utcnow().isoformat() + "Z",

tests/test_federation_router.py: 29 warnings
  C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\connectors\federation_router.py:287: DeprecationWarning: datetime.datetime.utcnow() is deprecated and scheduled for removal in a future version. Use timezone-aware objects to represent datetimes in UTC: datetime.datetime.now(datetime.UTC).
    timestamp=datetime.utcnow().isoformat(),

tests/test_memory_stack_v37.py: 8 warnings
tests/test_pipeline_routing.py: 2 warnings
  C:\Users\User\AppData\Local\Programs\Python\Python314\Lib\site-packages\numpy\linalg\_linalg.py:2792: RuntimeWarning: overflow encountered in dot
    sqnorm = x.dot(x)

tests/unit/test_api_app.py::TestAppCreation::test_create_app_returns_fastapi_instance
  C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\api\models_federation.py:29: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class FederationRouteRequest(BaseModel):

tests/unit/test_api_app.py::TestAppCreation::test_create_app_returns_fastapi_instance
  C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\api\models_federation.py:89: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class FederationRouteResponse(BaseModel):

tests/unit/test_api_app.py::TestAppCreation::test_create_app_returns_fastapi_instance
  C:\Users\User\OneDrive\Documents\GitHub\arifOS\arifos_core\api\models_federation.py:161: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class FederationStatusResponse(BaseModel):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/integration/test_failover_pipeline.py::test_all_providers_fail_returns_void
FAILED tests/integration/test_memory_policy_spec_alignment.py::TestSpecVsCodeVerdictRouting::test_all_verdicts_have_routing
FAILED tests/integration/test_sealion_api_key_detection.py::test_harness_validate_environment_detects_sealion_key
FAILED tests/integration/test_sealion_api_key_detection.py::test_harness_api_key_source_tracking
FAILED tests/test_caged_llm_harness.py::TestCagedLLMAntiHantu::test_anti_hantu_violation_detected_in_metrics
FAILED tests/test_caged_llm_harness.py::TestCagedLLMHighStakes::test_high_stakes_flag_affects_routing
FAILED tests/test_epoch_comparison.py::TestEpochComparison::test_amanah_consistency[amanah_001]
FAILED tests/test_failover_orchestrator.py::test_record_success_resets_failures
FAILED tests/test_failover_orchestrator.py::test_all_providers_fail_returns_void
FAILED tests/test_failover_orchestrator.py::test_governed_backend_lane_metadata
FAILED tests/test_governance_regression.py::TestResponseExtractionRobust::test_chatml_extraction
FAILED tests/test_governance_regression.py::TestResponseExtractionRobust::test_llama_extraction
FAILED tests/test_governance_regression.py::TestResponseExtractionRobust::test_response_tag_extraction
FAILED tests/test_governance_regression.py::TestResponseExtractionRobust::test_instruct_format_extraction
FAILED tests/test_governance_regression.py::TestResponseExtractionRobust::test_empty_input_returns_empty
FAILED tests/test_governance_regression.py::TestResponseExtractionRobust::test_no_truncation_artifacts
FAILED tests/test_governance_regression.py::TestAuditIncidents::test_incident_c_chatml_truncation
FAILED tests/test_governed_llm.py::TestGovernedPipeline::test_governed_answer_uses_pipeline
FAILED tests/test_law_truth_threshold_enforcement.py::TestTruthThresholdEnforcement::test_seal_impossible_with_truth_090
FAILED tests/test_law_truth_threshold_enforcement.py::TestTruthThresholdEnforcement::test_seal_impossible_with_truth_095
FAILED tests/test_law_truth_threshold_enforcement.py::TestTruthThresholdEnforcement::test_seal_impossible_with_truth_098
FAILED tests/test_law_truth_threshold_enforcement.py::TestTruthThresholdEnforcement::test_genius_law_path_respects_threshold
FAILED tests/test_llm_audit_trail.py::test_soft_lane_calls_llm - AssertionErr...
FAILED tests/test_phoenix_72_guardrail.py::TestPhoenix72Guardrail::test_entropy_constraint_satisfied
FAILED tests/test_pipeline_routing.py::TestPipelineRouting::test_force_class_b
FAILED tests/test_pipeline_routing.py::TestStageExecution::test_context_retriever_at_stage_111_applies_in_fast_track
FAILED tests/test_runtime_manifest.py::TestManifestLoadingV35::test_v35_manifest_file_exists
FAILED tests/test_runtime_manifest.py::TestManifestLoadingV35::test_v35_manifest_loads_without_error
FAILED tests/test_runtime_manifest.py::TestManifestLoadingV35::test_v35_manifest_has_version
FAILED tests/test_runtime_manifest.py::TestManifestLoadingV35::test_v35_manifest_has_epoch
FAILED tests/test_runtime_manifest.py::TestManifestLoadingV35::test_v35_manifest_has_status
FAILED tests/test_runtime_manifest.py::TestManifestLoadingV35::test_v35_validate_manifest_passes
FAILED tests/test_runtime_manifest.py::TestV37DefaultEpoch::test_v37_manifest_loads_by_default
FAILED tests/test_sovereignty_all_providers.py::TestHarnessMockMode::test_claude_harness_importable
FAILED tests/test_sovereignty_all_providers.py::TestHarnessMockMode::test_openai_harness_importable
FAILED tests/test_sovereignty_all_providers.py::TestHarnessMockMode::test_gemini_harness_importable
FAILED tests/test_sovereignty_all_providers.py::TestHarnessMockMode::test_sealion_sovereignty_script_importable
FAILED tests/test_spec_loader_unified.py::test_loader_priority_env_override
FAILED tests/test_spec_loader_unified.py::test_loader_priority_v42_default - ...
FAILED tests/test_spec_loader_unified.py::test_loader_fallback_to_hardcoded
FAILED tests/test_spec_loader_unified.py::test_loader_malformed_json_falls_through
FAILED tests/test_spec_loader_unified.py::test_loader_invalid_spec_falls_through
FAILED tests/test_spec_loader_unified.py::test_loaded_from_marker_accurate - ...
FAILED tests/test_spec_v44_manifest_enforcement_subprocess.py::TestConstitutionalFloorsManifestEnforcement::test_default_import_verifies_manifest_successfully
FAILED tests/test_spec_v44_manifest_enforcement_subprocess.py::TestConstitutionalFloorsManifestEnforcement::test_missing_manifest_triggers_hard_fail
FAILED tests/test_spec_v44_manifest_enforcement_subprocess.py::TestConstitutionalFloorsManifestEnforcement::test_legacy_mode_bypasses_manifest_verification
FAILED tests/test_spec_v44_manifest_enforcement_subprocess.py::TestGeniusLawManifestEnforcement::test_default_import_verifies_manifest
FAILED tests/test_spec_v44_schema_enforcement_subprocess.py::TestConstitutionalFloorsSchemaEnforcement::test_valid_v44_spec_attaches_schema_used_marker
FAILED tests/test_spec_v44_schema_enforcement_subprocess.py::TestGeniusLawSchemaEnforcement::test_valid_genius_spec_attaches_schema_used_marker
FAILED tests/test_spec_v44_subprocess_proof.py::TestConstitutionalFloorsSubprocess::test_default_load_uses_v44_fresh_process
FAILED tests/test_spec_v44_subprocess_proof.py::TestConstitutionalFloorsSubprocess::test_missing_v44_hard_fails_fresh_process
FAILED tests/test_spec_v44_subprocess_proof.py::TestConstitutionalFloorsSubprocess::test_env_override_loads_custom_spec_fresh_process
FAILED tests/test_spec_v44_subprocess_proof.py::TestGeniusMetricsSubprocess::test_default_load_uses_v44_fresh_process
FAILED tests/test_spec_v44_subprocess_proof.py::TestGeniusMetricsSubprocess::test_env_override_works_fresh_process
FAILED tests/test_spec_v44_subprocess_proof.py::TestSessionPhysicsSubprocess::test_default_load_uses_v44_fresh_process
FAILED tests/test_v39_ci_guardrails.py::TestConstitutionalInvariants::test_floor_ids_semantic
FAILED tests/test_v39_ci_guardrails.py::TestConstitutionalInvariants::test_precedence_explicit
FAILED tests/test_v39_ci_guardrails.py::TestConstitutionalInvariants::test_rasa_r1_enforced
FAILED tests/test_v39_ci_guardrails.py::TestConstitutionalInvariants::test_psi_canonical_preserved
FAILED tests/test_v39_ci_guardrails.py::TestSpecVersionAlignment::test_spec_version_is_v38_3_0
FAILED tests/test_v39_ci_guardrails.py::TestFloorCoverageCompleteness::test_all_floors_have_stage_hooks
FAILED tests/test_v39_ci_guardrails.py::TestFloorCoverageCompleteness::test_all_floors_have_thresholds
FAILED tests/test_v45_patch_b1_fixes.py::TestPatchA_LaneScopedPsi::test_soft_degrades_to_partial_on_low_psi
ERROR tests/test_canon_drift_guard.py::TestConstitutionalFloorsJsonMatchesMetrics::test_truth_threshold_matches
ERROR tests/test_canon_drift_guard.py::TestConstitutionalFloorsJsonMatchesMetrics::test_delta_s_threshold_matches
ERROR tests/test_canon_drift_guard.py::TestConstitutionalFloorsJsonMatchesMetrics::test_peace_squared_threshold_matches
ERROR tests/test_canon_drift_guard.py::TestConstitutionalFloorsJsonMatchesMetrics::test_kappa_r_threshold_matches
ERROR tests/test_canon_drift_guard.py::TestConstitutionalFloorsJsonMatchesMetrics::test_omega_0_band_matches
ERROR tests/test_canon_drift_guard.py::TestConstitutionalFloorsJsonMatchesMetrics::test_tri_witness_threshold_matches
ERROR tests/test_canon_drift_guard.py::TestConstitutionalFloorsJsonMatchesMetrics::test_psi_threshold_matches
ERROR tests/test_canon_drift_guard.py::TestFloorCategoriesMatchCanon::test_hard_floors_list
ERROR tests/test_canon_drift_guard.py::TestFloorCategoriesMatchCanon::test_soft_floors_list
ERROR tests/test_canon_drift_guard.py::TestFloorCategoriesMatchCanon::test_meta_floors_list
ERROR tests/test_canon_drift_guard.py::TestAntiHantuFloorType::test_anti_hantu_is_meta_type
ERROR tests/test_canon_drift_guard.py::TestAntiHantuFloorType::test_anti_hantu_failure_action_is_void
ERROR tests/test_canon_drift_guard.py::TestAntiHantuFloorType::test_anti_hantu_enforced_by_eye
ERROR tests/test_runtime_manifest.py::TestFloorThresholdDriftV35::test_truth_threshold_matches
ERROR tests/test_runtime_manifest.py::TestFloorThresholdDriftV35::test_delta_s_threshold_matches
ERROR tests/test_runtime_manifest.py::TestFloorThresholdDriftV35::test_peace_squared_threshold_matches
ERROR tests/test_runtime_manifest.py::TestFloorThresholdDriftV35::test_kappa_r_threshold_matches
ERROR tests/test_runtime_manifest.py::TestFloorThresholdDriftV35::test_omega_0_min_matches
ERROR tests/test_runtime_manifest.py::TestFloorThresholdDriftV35::test_omega_0_max_matches
ERROR tests/test_runtime_manifest.py::TestFloorThresholdDriftV35::test_tri_witness_threshold_matches
ERROR tests/test_runtime_manifest.py::TestFloorThresholdDriftV35::test_psi_threshold_matches
ERROR tests/test_runtime_manifest.py::TestFloorThresholdDriftV35::test_metrics_threshold_constants_match
ERROR tests/test_runtime_manifest.py::TestPipelineStagesV35::test_stage_000_exists
ERROR tests/test_runtime_manifest.py::TestPipelineStagesV35::test_stage_999_exists
ERROR tests/test_runtime_manifest.py::TestPipelineStagesV35::test_all_ten_stages_defined
ERROR tests/test_runtime_manifest.py::TestPipelineStagesV35::test_stage_000_is_void
ERROR tests/test_runtime_manifest.py::TestPipelineStagesV35::test_stage_888_is_judge
ERROR tests/test_runtime_manifest.py::TestPipelineStagesV35::test_stage_999_is_seal
ERROR tests/test_runtime_manifest.py::TestPipelineStagesV35::test_get_pipeline_stages_returns_ordered_list
ERROR tests/test_runtime_manifest.py::TestPipelineStagesV35::test_class_a_routing_defined
ERROR tests/test_runtime_manifest.py::TestPipelineStagesV35::test_class_b_routing_defined
ERROR tests/test_runtime_manifest.py::TestEngineModulesV35::test_arif_engine_module_exists
ERROR tests/test_runtime_manifest.py::TestEngineModulesV35::test_arif_engine_class_exists
ERROR tests/test_runtime_manifest.py::TestEngineModulesV35::test_adam_engine_module_exists
ERROR tests/test_runtime_manifest.py::TestEngineModulesV35::test_adam_engine_class_exists
ERROR tests/test_runtime_manifest.py::TestEngineModulesV35::test_apex_engine_module_exists
ERROR tests/test_runtime_manifest.py::TestEngineModulesV35::test_apex_engine_class_exists
ERROR tests/test_runtime_manifest.py::TestWAWOrganModulesV35::test_all_five_organs_defined
ERROR tests/test_runtime_manifest.py::TestWAWOrganModulesV35::test_well_organ_importable
ERROR tests/test_runtime_manifest.py::TestWAWOrganModulesV35::test_rif_organ_importable
ERROR tests/test_runtime_manifest.py::TestWAWOrganModulesV35::test_wealth_organ_importable
ERROR tests/test_runtime_manifest.py::TestWAWOrganModulesV35::test_geox_organ_importable
ERROR tests/test_runtime_manifest.py::TestWAWOrganModulesV35::test_prompt_organ_importable
ERROR tests/test_runtime_manifest.py::TestWAWOrganModulesV35::test_federation_core_importable
ERROR tests/test_runtime_manifest.py::TestEyeSentinelViewsV35::test_eleven_views_defined
ERROR tests/test_runtime_manifest.py::TestEyeSentinelViewsV35::test_eye_sentinel_coordinator_importable
ERROR tests/test_runtime_manifest.py::TestEyeSentinelViewsV35::test_all_views_importable
ERROR tests/test_runtime_manifest.py::TestEyeSentinelViewsV35::test_blocking_rule_defined
ERROR tests/test_runtime_manifest.py::TestMetricsModuleV35::test_metrics_module_importable
ERROR tests/test_runtime_manifest.py::TestMetricsModuleV35::test_metrics_dataclass_exists
ERROR tests/test_runtime_manifest.py::TestMetricsModuleV35::test_check_functions_exist
ERROR tests/test_runtime_manifest.py::TestHarnessEntryPointV35::test_harness_module_importable
ERROR tests/test_runtime_manifest.py::TestHarnessEntryPointV35::test_cage_llm_response_callable
ERROR tests/test_runtime_manifest.py::TestHarnessEntryPointV35::test_caged_result_class_exists
ERROR tests/test_runtime_manifest.py::TestHarnessEntryPointV35::test_get_harness_entry_returns_correct_info
ERROR tests/test_runtime_manifest.py::TestHelperFunctionsV35::test_get_floor_threshold_truth
ERROR tests/test_runtime_manifest.py::TestHelperFunctionsV35::test_get_floor_threshold_omega_returns_range
ERROR tests/test_runtime_manifest.py::TestHelperFunctionsV35::test_get_floor_threshold_invalid_raises
ERROR tests/test_runtime_manifest.py::TestLedgerModulesV35::test_cooling_ledger_module_importable
ERROR tests/test_runtime_manifest.py::TestLedgerModulesV35::test_vault999_seal_json_path_valid
ERROR tests/test_runtime_manifest.py::TestLedgerModulesV35::test_phoenix72_module_importable
ERROR tests/test_runtime_manifest.py::TestCanonFileReferencesV35::test_runtime_law_files_exist
ERROR tests/test_runtime_manifest.py::TestCanonFileReferencesV35::test_constitutional_floors_json_exists
= 63 failed, 1976 passed, 10 skipped, 65 warnings, 63 errors in 219.35s (0:03:39) =
